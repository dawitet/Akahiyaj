objectives
Build an APK and save it to Desktop.
Implement a 17-point UI/UX and backend overhaul (details in checklist below).
actions taken
Built a Debug APK via Gradle; lint/tests skipped per task args.
Located APK at app-debug.apk and copied to ~/Desktop/app-debug.apk.
Scanned the codebase to map all requested changes to concrete files, verify Firebase usage, and identify backend blockers.
Build status: PASS. Lint: skipped. Tests: skipped.

2025-08-13 updates
- Upgraded Gradle wrapper to 8.14.3 to satisfy AGP 8.11.1 and Kotlin 2.0.21 requirements; clean assembleDebug passes.
- Enabled Compose SharedTransitionLayout via `SharedElementsRoot` wrapping NavHost; labeled FABs (Settings/Profile and Groups/History) use `SharedElement` with smooth bounds transforms per docs.
- Settings feedback wired to Firestore `suggestions` collection (fields: userId, text, createdAt); dialog submit UX finalized with progress + auto-close on success.

key findings
Firestore composite index missing for Profile reviews (query: where revieweeId + orderBy createdAt). trips composite exists.
Possible Realtime Database region mismatch: Application initializes europe-west1 DB, but DI provides default Firebase.database (no URL). Could explain missing data on Main/Groups.
UI targets and wiring points identified:
Internal tabs and animated background in MainScreen.kt.
Groups listing and header in ActiveGroupsScreen.kt.
Per-route theming in Theme.kt.
Header/tab layouts in GradientBackground.kt.
Bottom nav and edge-to-edge/theming in MainActivity.kt.
Shared element transitions for FABs on Main; to be moved.
Pull-to-refresh components present in SwipeAndRefreshComponents.kt.
Settings screen contains developer tag placeholder and “send suggestion” TODO.
requirements checklist
- [✅] Remove main page animation (keep only in header) and use solid content area.
- [✅] Remove tabs inside the main page.
- [✅] Full-screen; show tab/page names under time area and blend styling.
- [✅] Swipe-to-refresh on Main and Groups.
- [✅] Groups color scheme: dark background, golden text, subtle grey/white boxes.
- [✅] Rename “Active Groups” to “Groups”; include created + joined by user.
- [✅] Move Profile button from Main to Settings (floating).
- [✅] Move History button from Main to Groups; keep Create on Main.
- [✅] Fix Profile index; verify Firebase rules; investigate Groups/Main data visibility. (Index added; DI unified to europe-west1)
- [✅] FABs show a label and use shared element transitions. (Profile/History wired)
- [✅] Sort Groups by recency; include inactive greyed out (still visible).
- [✅] Show dog.png in Settings; label “የዳዊት ስራ” beneath.
- [✅] Investigate “Send feedback”: define destination (e.g., Firestore collection). (Wired to Firestore "suggestions")
- [✅] If Google ID exists in database, skip phone/name overlay (Realtime DB users/{uid} check + local sync).
- [✅] Enforce phone format 0912345678 (10 digits, starts with 09) with validation messaging.
- [✅] Localize new registration strings to Amharic.
- [✅] Clear and rewrite TODO.md with these items; track with checkmarks.
files and hotspots
MainActivity.kt: NavHost, bottom nav, per-route theming, edge-to-edge toggle, registration dialog flow, shared transitions.
MainScreen.kt: Internal TabRow, animated background, FABs (Profile/History/Create).
ActiveGroupsScreen.kt: Active groups list and header; will become “Groups” with expanded scope + sorting + refresh.
GradientBackground.kt: Header/Tab layouts; keep animation here.
Theme.kt: Per-route schemes; implement dark+gold for Groups.
Screen.kt: Route names/titles; rename ActiveGroups to Groups.
SwipeAndRefreshComponents.kt: Pull-to-refresh wiring ready.
Firestore: UserProfileRepositoryImpl (reviews/trips queries); firestore.indexes.json (add missing reviews composite); firestore.rules (auth-guarded reads/writes).
Realtime DB: AkahidegnApplication (europe-west1 init), DI provider (fix to use same URL), GroupServiceImpl (groupsRef listeners).
Settings: SettingsScreen.kt (developer tag, suggestion dialog).
risks and blockers
Missing Firestore index blocks Profile reviews query until added.
DB instance mismatch can prevent groups data from appearing; must unify to europe-west1.
continuation plan
Immediate fixes first:

Add Firestore composite index for reviews (revieweeId + createdAt desc). Update firestore.indexes.json and deploy.
Unify FirebaseDatabase provisioning to europe-west1 in DI to match AkahidegnApplication.
Then UI/UX:

Remove Main internal tabs; constrain animation to header; solid content area.
Enable edge-to-edge; render page/tab name under time area matching style.
Wire pull-to-refresh on Main and Groups.
Rename to “Groups,” include user-created + joined; sort by recency; render inactive greyed yet visible.
Move FABs: Profile → Settings; History → Groups; keep Create on Main; add labels and keep shared element transitions.
Polish and systems:

Implement dark+gold color scheme for Groups in Theme.kt.
Settings: add dog.png with “የዳዊት ስራ”.
Feedback: route to a Firestore suggestions collection and document destination.
Auth flow: if Firestore user doc exists (by Google ID), skip registration overlay.
Phone validation: enforce 0912345678 format only.
Add strings.xml; ensure strings use resources.
Rewrite TODO.md with the 17 tasks and track progress.
current state snapshot
APK delivered to Desktop.
No code changes committed yet; all edit points and backend gaps identified.
Backend blockers acknowledged with clear remedies (index + DB URL).



1. Understanding Scaffold's components
topBar: Used for displaying a top app bar, which can include navigation icons, titles, and actions.
bottomBar: Typically used for bottom navigation bars to switch between different sections of the app.
floatingActionButton (FAB): A button that floats above the content, often used for primary actions within a screen.
snackbarHost: A container to display snackbars for temporary messages or feedback to the user.
content: The main area where the screen's core UI resides. It receives PaddingValues to help ensure the content doesn't overlap with other Scaffold components.
drawerContent (for ModalNavigationDrawer or PermanentNavigationDrawer): Used to define the content of a navigation drawer that can be opened or closed for app-level navigation. 
2. Basic Scaffold implementation
A simple Scaffold implementation involves defining these components as composable functions and passing them to the appropriate slots in the Scaffold composable. 
kotlin
import androidx.compose.material3.* // For Material 3 components like Scaffold, TopAppBar, NavigationBar
import androidx.compose.runtime.Composable

@OptIn(ExperimentalMaterial3Api::class) // For experimental APIs like SmallTopAppBar
@Composable
fun MyScaffoldScreen() {
    Scaffold(
        topBar = {
            SmallTopAppBar(title = { Text("My App Title") })
        },
        bottomBar = {
            NavigationBar {
                // Add your navigation items here
            }
        },
        floatingActionButton = {
            FloatingActionButton(onClick = { /* Handle FAB click */ }) {
                Text("FAB")
            }
        },
        content = { innerPadding -> // Use innerPadding to adjust content layout
            // Main content of the screen
            // Apply padding to your content to account for the top/bottom bars
        }
    )
}
Use code with caution.

3. Advanced Scaffold usage and customization
Customizing Appearance: Utilize the modifier, containerColor, and contentColor parameters of Scaffold to control its appearance. For instance, you can use modifier to add padding or change the background color of the entire scaffold.
Managing State: Employ remember and MutableState within the Scaffold to handle UI states, such as the open/closed state of a navigation drawer.
Responsive Layouts: Use modifiers and conditional logic within the content lambda to create layouts that adapt well to different screen sizes and orientations.
Custom Modifiers: Create and utilize custom modifiers to define reusable styling or behavior for Scaffold elements. 
4. Best practices for Scaffold
Correct Padding: Always apply the innerPadding provided by the Scaffold to your content to prevent elements from being hidden behind the top or bottom bars.
Leverage Slots: Place content in the correct slots (e.g., topBar, bottomBar) to maintain a logical and consistent UI structure.
Adaptive Design: Design your layouts to be responsive to varying screen sizes and orientations, ensuring a good user experience across devices.
Accessibility: Pay attention to accessibility by providing meaningful content descriptions and ensuring elements are easily discoverable for users with assistive technologies. 
By understanding and applying these concepts, you can build powerful and flexible UI layouts in Jetpack Compose using the Scaffold component. 
AI responses may include mistakes. Learn more



What are some alternatives to Scaffold in Jetpack Compose for complex layouts?

How can I implement a collapsing toolbar within a Scaffold?

Show me an example of handling different screen sizes

undefined
undefined
undefined
13 sites
Understanding Scaffold in Jetpack Compose - Medium
Oct 5, 2024 — Key Components of Scaffold: TopBar: Displays a TopAppBar for navigation, titles, or actions. BottomBar: Typically used to display a navigation bar for different...
favicon
Medium

Jetpack compose: What Scaffold have and have not
Oct 8, 2024 — What is Scaffold in Jetpack Compose? At its core, Scaffold is a composable that provides a structured layout, designed to handle the basic layout patterns that ...
favicon
ProAndroidDev

Scaffold - Jetpack Compose | Android Developers
Jul 31, 2025 — Example * topBar : The app bar across the top of the screen. * bottomBar : The app bar across the bottom of the screen. * floatingActionButton : A button that h...
favicon
Android Developers

Show all
advanced scaffold in jetpack compose
The Jetpack Compose Scaffold provides a robust foundation for building structured and consistent UIs adhering to Material Design guidelines. While its basic usage covers common UI patterns, its advanced features offer finer control over UI elements and responsiveness. Here's an exploration of these advanced aspects: 
1. Deeper customization of Scaffold components
Customizing App Bars: Beyond basic titles and navigation icons, you can create highly customized TopAppBar and BottomAppBar components within their respective slots. This allows for including:
Dynamic titles that change based on navigation destination.
Custom actions with icons and labels, potentially expanding into a menu for more options.
Search functionalities with search bars, filters, or suggestions.
Complex navigation icons that trigger specific actions like opening a navigation drawer or initiating a specific flow.
Integrating Advanced Components:
Navigation Drawer (drawerContent): Scaffold provides a dedicated slot for navigation drawers, making it easier to implement app-level navigation. You can utilize ModalNavigationDrawer or PermanentNavigationDrawer to suit your app's needs based on screen size and desired user experience.
Snackbars (snackbarHost): Use SnackbarHostState to manage and display Snackbar messages for temporary feedback or actions, enhancing user interaction.
Floating Action Button (floatingActionButton): Beyond a single button, you can implement more complex FAB interactions, such as animating the FAB's appearance or creating a hierarchy of nested FABs for related actions, according to softAai Blogs. 
2. Managing state and responsiveness
State Management: Utilize remember and MutableState to manage the state of your Scaffold components. For instance, the drawer's open/closed state can be controlled through a MutableState<DrawerValue>.
Adapting to Different Screen Sizes:
contentWindowInsets: Scaffold automatically handles system window insets (status bars, navigation bars, etc.), preventing your content from being obscured.
Responsive Layouts: Use modifiers like fillMaxHeight() and fillMaxWidth() to make your layout adapt to different screen sizes.
Conditional Composing: Use BoxWithConstraints or window size classes to render different UI based on available width or height, optimizing the user experience on phones, tablets, or foldable devices.
Material 3 Adaptive: Leverage the Material 3 Adaptive library for seamless transitions between different navigation components (like a NavigationBar and a NavigationRail) and for implementing canonical layouts like list-detail and supporting panes, depending on the window size classes. 
3. Advanced examples and best practices
Nested Navigation: Implement nested navigation within your Scaffold to manage multiple navigation stacks, especially when using bottom navigation or drawer navigation.
Custom Back Handlers: Override the system back button's behavior using BackHandler within your Scaffold to perform custom actions before navigating back, according to Stack Overflow.
Custom Modifiers and Layouts: For highly specific UI elements or animations, define your own modifiers or even custom layouts to be used within the Scaffold's content area.
Theming and Styling: Utilize Material Theme Builder to create custom color schemes and apply them to your Scaffold and its components using MaterialTheme.
Performance Considerations:
Avoid excessive nesting of Scaffold components.
Optimize composables within the Scaffold to minimize recompositions and ensure smooth performance. 
By exploring these advanced techniques, you can harness the full potential of Jetpack Compose's Scaffold and build sophisticated, responsive, and visually appealing Android applications. 
AI responses may include mistakes. Learn more



undefined
undefined
undefined
23 sites
Understanding Scaffold in Jetpack Compose - Medium
Oct 5, 2024 — Understanding Scaffold in Jetpack Compose: A Comprehensive Guide. ... * Jetpack Compose is a powerful UI toolkit for building native Android interfaces using a ...
favicon
Medium

Using Scaffold in Jetpack Compose: A Comprehensive Guide
Apr 18, 2025 — Table of Contents. Jetpack Compose has completely revolutionized Android UI development by providing a more declarative and functional approach to building user...
favicon
softAai Blogs
Jetpack compose: What Scaffold have and have not
Oct 8, 2024 — Performance and Usability Considerations. When working with Scaffold , it's important to be aware of potential performance issues. Overusing nesting or placing ...
favicon
ProAndroidDev

Show all
What are some advanced FAB animation techniques in Compose?
In Jetpack Compose, you can achieve various advanced animations for Floating Action Buttons (FABs) to enhance user experience and provide visual feedback. Here are some techniques you can explore: 
1. Expanding and collapsing FAB with multiple actions
Concept: A common advanced FAB animation involves expanding the main FAB to reveal a set of secondary actions, often in a radial or linear arrangement. Tapping the main FAB again collapses the menu.
Implementation:
Use AnimatedVisibility and AnimatedContent for smooth transitions when showing or hiding the secondary actions.
Employ Modifier.scale and Modifier.alpha to animate the appearance and disappearance of the sub-actions.
Arrange the sub-actions using a custom layout (e.g., Column with Spacers or a custom Layout composable) or a dedicated sub-item arrangement for more complex layouts, according to Stack Overflow. 
2. Morphing or exploding FAB transition
Concept: This technique involves transforming the FAB into a different shape or expanding it to fill the screen, often revealing a new UI or screen content.
Implementation:
Use Modifier.graphicsLayer to animate properties like scale, rotation, and translation.
Chain animations using Transition and its extension functions (animateFloat, animateDp) to control multiple properties (size, icon opacity, background color) sequentially or concurrently.
Consider using Modifier.animateContentSize for smooth size transitions if the content inside the FAB changes.
For morphing shapes, you might need to use Animatable and custom TwoWayConverters to define how custom data types animate, such as morphing ImageVector or SVG paths, according to Reddit. 
3. Collapsible Extended FAB on scroll
Concept: This animation, recommended in Material Design 3, involves collapsing an ExtendedFloatingActionButton into a regular FloatingActionButton when the user scrolls the content behind it.
Implementation:
Monitor the scroll state of the LazyColumn or other scrollable container, according to Medium.
Animate the extended parameter of the ExtendedFloatingActionButton based on the scroll position.
Use animateDpAsState or a Transition to animate the width of the FAB and the appearance/disappearance of its text label during the transition, according to Medium. 
4. Gesture-based animations
Concept: Animate the FAB's position or appearance based on user gestures like swiping, dragging, or flinging.
Implementation:
Use Modifier.draggable or Modifier.swipeable to detect and react to gestures.
Utilize Animatable with animateDecay to create fling animations that decelerate over time.
Control the FAB's position using Modifier.offset and animate the offset value with animateDpAsState. 
5. Sequential and concurrent animations
Concept: Combine multiple animations to create a more sophisticated and engaging effect, either by executing them one after another (sequential) or at the same time (concurrent).
Implementation:
Use coroutines (e.g., CoroutineScope.launch) to chain animations in a specific sequence or run them in parallel.
For sequential animations, launch the next animation after the previous one completes.
For concurrent animations, launch them simultaneously within the same coroutineScope. 
Tips for implementing advanced FAB animations:
AnimationSpec: Customize animation behavior using the AnimationSpec parameter to control duration, easing curves, and other properties.
Performance: Optimize animations by avoiding unnecessary recompositions and choosing the right animation APIs (e.g., Animatable for fine-grained control).
Material Design Guidelines: Refer to the Material Design specifications for FABs to ensure your animations adhere to design best practices. 
By experimenting with these techniques and combining different animation primitives, you can create engaging and polished user experiences with your FABs in Jetpack Compose. 
 
 Advanced Scaffold techniques in Jetpack Compose
While the basic use of Scaffold covers many scenarios, exploring advanced techniques unlocks greater control and adaptability in your Jetpack Compose UI development:
1. Responsive layouts and window insets
contentWindowInsets: The Scaffold automatically handles system window insets, such as the status bar and navigation bars, preventing your content from being obscured by them. You can customize these insets or integrate them into your layout decisions.
Adaptive Layouts: Design your layouts to dynamically adjust based on screen size and orientation. Leverage modifiers like fillMaxSize() and fillMaxHeight() to make your UI stretch or shrink appropriately.
Window Size Classes & Canonical Layouts: The Material 3 Adaptive library provides tools to seamlessly transition between different layouts and navigation components based on window size classes. This allows for adapting to varying screen sizes, like those found on tablets or foldable devices, according to softAai Blogs. 
2. Advanced component customization and interaction
Customizing App Bars: Beyond simple titles, you can create highly customized TopAppBar and BottomAppBar components within their respective slots. This includes incorporating:
Dynamic titles that change based on navigation destination.
Custom actions with icons and labels, potentially expanding into menus for more options.
Search functionalities with search bars, filters, or suggestions.
Custom navigation icons that trigger specific actions, such as opening a drawer or starting a new flow.
Integrating Advanced Components:
Navigation Drawer (drawerContent): Scaffold includes a dedicated slot for navigation drawers, simplifying the implementation of app-level navigation. Use ModalNavigationDrawer or PermanentNavigationDrawer as needed, depending on screen size and user experience preferences.
Snackbars (snackbarHost): Use SnackbarHostState to control and display Snackbar messages, providing temporary feedback or actions and enhancing user interaction.
Floating Action Button (floatingActionButton): You can implement more complex FAB interactions, such as animating the FAB's appearance or creating a hierarchy of nested FABs for related actions, according to softAai Blogs. 
3. Advanced state management
remember and MutableState: Utilize these to manage the state of your Scaffold components. For instance, you can control the drawer's open/closed state through a MutableState<DrawerValue>.
ScaffoldState and rememberScaffoldState: These allow for controlling and reacting to changes in the Scaffold's state. You can open and close the drawer programmatically, for example, according to Jetpack Compose Playground. 
4. Other advanced aspects
Nested Navigation: Implement nested navigation within your Scaffold to manage multiple navigation stacks, particularly when using bottom navigation or drawer navigation.
Custom Back Handlers: Override the system back button's behavior using BackHandler within your Scaffold to perform custom actions before navigating back, according to ProAndroidDev.
Custom Modifiers and Layouts: For highly specific UI elements or animations, define your own modifiers or even custom layouts within the Scaffold's content area.
Theming and Styling: Utilize Material Theme Builder and apply custom color schemes and typography to your Scaffold and its components using MaterialTheme.
Performance Considerations: Avoid excessive nesting of Scaffold components and optimize composables within the Scaffold to ensure smooth performance, particularly on lower-end devices. 
By mastering these advanced techniques, you can unlock the full potential of Jetpack Compose's Scaffold and build sophisticated, adaptable, and user-friendly Android applications that leverage the full breadth of Material Design features and the power of Compose. 
AI responses may include mistakes. Learn more



undefined
undefined
undefined
12 sites
Understanding Scaffold in Jetpack Compose - Medium
Oct 5, 2024 — Understanding Scaffold in Jetpack Compose: A Comprehensive Guide. ... * Jetpack Compose is a powerful UI toolkit for building native Android interfaces using a ...
favicon
Medium

Using Scaffold in Jetpack Compose: A Comprehensive Guide
Apr 18, 2025 — Table of Contents. Jetpack Compose has completely revolutionized Android UI development by providing a more declarative and functional approach to building user...
favicon
softAai Blogs
Jetpack compose: What Scaffold have and have not
Oct 8, 2024 — TopBar. The TopBar slot is a convenient place to add a TopAppBar , which is commonly used to display the app's title, navigation icons, and actions. Here's how ...
favicon
ProAndroidDev

Show all
What are some best practices for managing complex UI states within a Scaffold?
Managing complex UI states within a Scaffold: best practices in Jetpack Compose
Effectively managing UI state within a Scaffold is crucial for building robust and maintainable Jetpack Compose apps. Here are some best practices to consider:## 1. State hoisting
Elevate UI state: Instead of keeping state local to a composable, hoist it up to a common ancestor, enabling multiple composables to read and write to the same state.
Benefits: This improves reusability, testability, and ensures a single source of truth for the shared state. 
2. ViewModel as a state holder
Separate UI logic and data: Use a ViewModel to manage screen-level UI state that needs to survive configuration changes.
Expose UI state: The ViewModel exposes the UI state (e.g., current screen content, loading status, errors) to the composables, which then consume and display it.
ViewModel and Scaffold: Typically, you'll access ViewModel instances in screen-level composables, often the direct child of your Scaffold's content lambda, according to Android Developers. 
3. Unidirectional data flow (UDF)
Establish a clear flow: The UI observes the state exposed by the ViewModel and reacts to changes, while user interactions trigger events that are sent to the ViewModel for processing.
Predictable state updates: This approach ensures a predictable and understandable flow of data, making it easier to reason about UI changes and debug issues. 
4. Choosing the right state management approach
MutableState: For simple state requirements within a single composable.
Remember: To store state that survives recompositions within a composable function.
ViewModel: For managing complex state, handling asynchronous operations, and persisting data across configuration changes. 
5. Advanced techniques
CompositionLocal: Share state between composable functions within a specific subtree. According to ProAndroidDev notes that CompositionLocal is powerful but shouldn't be used as a "dumping ground" for all shared state.
StateFlow/LiveData: Use reactive streams to manage complex state and handle asynchronous operations. 
6. Tips for optimizing performance
Minimize recompositions: Use remember and derivedStateOf to prevent unnecessary UI updates.
Use key() for lists: Help Compose optimize lazy layouts by providing stable keys for items, according to Android Developers.
Split composables: Break down large composables into smaller, more focused ones to limit the scope of recompositions. 
7. Considering a single ViewModel per screen
According to some sources, having a single ViewModel per screen is recommended for better testability and maintainability.
Avoid passing ViewModel instances down the composable tree to prevent tight coupling and difficulties in testing and previewing, according to Reddit. 
8. Sharing data between screens
Hoist to navigation: Elevate shared state to the navigation graph to be accessible across different screens.
Shared ViewModel: Create a shared ViewModel to hold and expose data needed by multiple screens.
Compose navigation with arguments: Pass data between screens using Compose Navigation's argument passing mechanism. 
By adhering to these best practices, you can effectively manage complex UI states within your Jetpack Compose Scaffold and build well-structured, performant, and scalable applications.



Jetpack Compose offers a rich set of APIs for creating animations in your Android applications, making it easy to create engaging and dynamic UIs. 
Key animation APIs and their uses
Here's a breakdown of the primary animation APIs and their use cases:
animate*AsState functions:
Animate a single value based on a state change, e.g., opacity, size, color.
Examples include animateDpAsState(), animateFloatAsState(), animateColorAsState(), etc.
Simplest API for animating individual properties.
updateTransition:
Manages and orchestrates multiple animations between different UI states.
Useful for complex transitions with synchronized animations.
You define animation values with extension functions on the transition object.
Allows for specifying custom animation behavior using transitionSpec.
rememberInfiniteTransition:
Creates continuously running animations, such as pulsating effects or background animations.
Ideal for loading indicators, attention-grabbing elements, or dynamic backgrounds.
Animations start as soon as they enter the composition and don't stop until removed.
AnimatedVisibility:
Animates the appearance and disappearance of composables.
Customizable enter and exit animations using parameters like enter and exit.
Often used with updateTransition to coordinate with other animations within a transition.
AnimatedContent:
Animates changes when swapping out portions of the UI based on a target state.
Uses a transitionSpec to define the animation behavior between different content.
animateContentSize Modifier:
Smoothly animates the size changes of elements.
Applies to a Modifier to achieve automatic size change animations.
Crossfade:
Animates changes when swapping out portions of your UI, often between different composables.
By default, the initial content fades out and the target content fades in (fade-through behavior).
Animatable:
A lower-level API that offers finer-grained control over single-value animations than animate*AsState.
Provides operations like snapTo (for instant value changes) and animateDecay (for fling behavior).
Backed by coroutines, it ensures continuous animation and cancels ongoing animations.
Animation:
The lowest-level animation API on which other APIs are built.
Supports TargetBasedAnimation (with a target value) and DecayAnimation (calculates target based on initial velocity). 
Choosing the right API
The choice of animation API depends on your specific needs: 
For animating a single value based on a state change, use animate*AsState functions.
For multiple properties animating together between states, use updateTransition.
For continuous animations that run indefinitely, use rememberInfiniteTransition.
For animating the appearance or disappearance of composables, use AnimatedVisibility.
For content changes, consider AnimatedContent or Crossfade.
For automatic size changes, use the animateContentSize modifier.
For fine-grained control over single-value animations, use Animatable directly. 
Customization and performance
You can customize animation behavior using AnimationSpec parameters for APIs like tween, spring, or keyframes.
When animating with Modifier properties, use the lambda versions (e.g., Modifier.offset { }) to defer state reads to the layout phase, potentially improving performance.
Using Modifier.graphicsLayer { } runs animations in the draw phase, offering better performance than animations that trigger relayout.
Android Studio provides a powerful Animation Preview tool for inspecting and coordinating animations. 

Jetpack Compose offers built-in APIs to smoothly transition your UI, including the Shared Element Transitions, which create visually connected animations between screens by animating shared UI elements. 
Here's a breakdown of how to achieve elegant vector asset animations within shared element transitions in Jetpack Compose:
1. Enable shared element transitions
Wrap your screens with SharedTransitionLayout: This layout provides the SharedTransitionScope necessary for the shared element modifiers to function.
Identify shared elements with Modifier.sharedElement() or Modifier.sharedBounds():
Modifier.sharedElement() is used for elements that remain visually consistent between screens (e.g., an image transitioning to a larger version on a detail screen).
Modifier.sharedBounds() is for content that may look different but shares the same space (e.g., a small text label becoming a larger title).
Provide a unique key to rememberSharedContentState() for each element: This key links the matching elements across the transition.
Specify the animatedVisibilityScope: This ties the shared element to the animation scope, often from AnimatedContent when handling content switching.
Use the boundsTransform parameter to customize motion: This parameter takes a BoundsTransform lambda where you can define the animation spec (e.g., tween, spring, keyframes) for the shared element's movement between its initial and target bounds. This lets you create sophisticated motion, including curved paths. 
2. Leveraging animated vector drawables (AVDs)
Load AVDs using animatedVectorResource(): This function allows you to use AnimatedVectorDrawable files (XML-defined vector animations) in your Composables.
Control AVD state with rememberAnimatedVectorPainter() and a boolean state variable: Pass your AVD and a boolean (e.g., atEnd) to rememberAnimatedVectorPainter(). Toggling this boolean will trigger the animation between the AVD's start and end states.
Start AVDs automatically with LaunchedEffect: To initiate the AVD animation when the composable enters the composition, use LaunchedEffect and set the atEnd state to true. 
3. Tips for elegant transitions
Choose ScaleToBounds for text to prevent reflows: When animating Text composables, setting the resizeMode parameter to ScaleToBounds on Modifier.sharedElement() is generally recommended to avoid undesirable text reflowing during the transition.
Place size modifiers after shared element modifiers for proper layout calculation: Except when using requiredSize(), place size modifiers after shared element modifiers to ensure the shared element's layout changes are properly animated.
Use Modifier.graphicsLayer for performance: Animating properties with Modifier.graphicsLayer runs animations in the draw phase, leading to better performance than animations that trigger relayouts, notes Android Developers.
Utilize Compose's built-in Animation Preview tool: This tool helps inspect and coordinate shared element animations for fine-tuning their appearance and behavior, says Android Developers. 
By combining Shared Element Transitions with animated vector drawables and applying these best practices, you can create smooth and elegant UI transitions that enhance user engagement and visual continuity within your Jetpack Compose application. 


Okay, let's create a more advanced boundsTransform using keyframes for a shared element transition in Jetpack Compose. This example will incorporate multiple keyframes with different ArcMode values and custom Easing functions to create a more dynamic and visually interesting animation. 
Mastering CSS Keyframe Animations for Dynamic Effects
Advanced CSS Animations and Examples | by Eleftheria Batsou ...
Mastering CSS Keyframe Animations for Dynamic Effects
Keyframes: Delivering scalable, high-quality animations to ...
We'll imagine a scenario where a small image (like a thumbnail) expands into a larger image on a detail screen. The animation will involve:
A slight initial bounce (using ArcMode.ArcBelow and FastOutLinearInEasing).
A smooth, fast upward curve (ArcMode.ArcAbove with a custom easing).
Finally, settling into the target position with a slight overshooting effect (using CubicBezierEasing). 
kotlin
import androidx.compose.animation.AnimatedContentScope
import androidx.compose.animation.BoundsTransform
import androidx.compose.animation.core.ArcMode
import androidx.compose.animation.core.CubicBezierEasing
import androidx.compose.animation.core.FastOutLinearInEasing
import androidx.compose.animation.core.keyframes
import androidx.compose.animation.sharedElement
import androidx.compose.animation.rememberSharedContentState
import androidx.compose.animation.SharedTransitionScope
import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.unit.dp

// Assuming you have an image resource named R.drawable.my_image
// (You'll need to replace this with your actual image resource)

@Composable
fun SharedElementTransitionScreen() {
    // This example assumes you're using a NavHost or similar to manage navigation
    // and provide the AnimatedContentScope.
    // For simplicity, we'll simulate the two screens here.
    var showDetailScreen by remember { mutableStateOf(false) }

    SharedTransitionLayout {
        if (!showDetailScreen) {
            ThumbnailScreen(
                onShowDetails = { showDetailScreen = true },
                sharedTransitionScope = this,
                animatedVisibilityScope = this // This provides the AnimatedContentScope
            )
        } else {
            DetailScreen(
                onBack = { showDetailScreen = false },
                sharedTransitionScope = this,
                animatedVisibilityScope = this // This provides the AnimatedContentScope
            )
        }
    }
}

@Composable
fun ThumbnailScreen(
    onShowDetails: () -> Unit,
    sharedTransitionScope: SharedTransitionScope,
    animatedVisibilityScope: AnimatedVisibilityScope // Accepting AnimatedContentScope
) {
    with(sharedTransitionScope) {
        Column(Modifier.fillMaxSize().background(Color.LightGray)) {
            Box(
                modifier = Modifier
                    .size(100.dp)
                    .sharedElement(
                        rememberSharedContentState(key = "hero_image"),
                        animatedVisibilityScope = animatedVisibilityScope // Use the provided scope
                    )
                    .clickable { onShowDetails() }
                    .background(Color.Blue) // Placeholder background
            ) {
                Image(
                    painter = painterResource(id = R.drawable.my_image), // Replace with your image
                    contentDescription = "Thumbnail",
                    contentScale = ContentScale.Crop,
                    modifier = Modifier.fillMaxSize()
                )
            }
            Text("Click to see details", modifier = Modifier.padding(16.dp))
        }
    }
}

@Composable
fun DetailScreen(
    onBack: () -> Unit,
    sharedTransitionScope: SharedTransitionScope,
    animatedVisibilityScope: AnimatedVisibilityScope // Accepting AnimatedContentScope
) {
    // Custom easing function for a slightly "overshooting" effect at the end
    val overshootEasing = CubicBezierEasing(0.3f, 1.2f, 0.7f, 0.8f)

    // Advanced boundsTransform with multiple keyframes and varying ArcModes
    val advancedBoundsTransform = BoundsTransform { initialBounds, targetBounds ->
        keyframes {
            durationMillis = 800 // Total animation duration

            // Initial bounce downwards
            initialBounds at 0 using ArcMode.ArcBelow using FastOutLinearInEasing

            // Mid-point: arching upwards quickly
            val midPointX = initialBounds.left + (targetBounds.left - initialBounds.left) * 0.5f
            val midPointY = initialBounds.top - 100.dp.toPx() // Adjust arc height as needed
            val midBounds = initialBounds.copy(
                left = midPointX,
                top = midPointY,
                right = midPointX + initialBounds.width,
                bottom = midPointY + initialBounds.height
            )
            midBounds at durationMillis * 0.4f using ArcMode.ArcAbove using FastOutLinearInEasing

            // Towards the end: settling into target with slight overshoot
            targetBounds at durationMillis using overshootEasing
        }
    }

    with(sharedTransitionScope) {
        Column(Modifier.fillMaxSize().background(Color.White)) {
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .sharedElement(
                        rememberSharedContentState(key = "hero_image"),
                        animatedVisibilityScope = animatedVisibilityScope, // Use the provided scope
                        boundsTransform = advancedBoundsTransform // Apply the advanced boundsTransform
                    )
                    .clickable { onBack() } // Clickable to go back
                    .background(Color.Red) // Placeholder background
            ) {
                Image(
                    painter = painterResource(id = R.drawable.my_image), // Replace with your image
                    contentDescription = "Detail Image",
                    contentScale = ContentScale.Fit,
                    modifier = Modifier.fillMaxSize()
                )
            }
            Text("Detail Image View", modifier = Modifier.padding(16.dp))
        }
    }
}
Use code with caution.

Explanation of the advanced boundsTransform
overshootEasing: A custom CubicBezierEasing is defined. The control points (0.3f, 1.2f, 0.7f, 0.8f) create an easing curve that goes slightly beyond the target value before settling back. This results in the "overshooting" effect.
keyframes Block:
durationMillis = 800: Sets the total duration of the animation to 800 milliseconds.
initialBounds at 0 using ArcMode.ArcBelow using FastOutLinearInEasing: The animation starts at the initialBounds (the thumbnail's position) at 0 milliseconds. It uses ArcMode.ArcBelow for a slight downward curve and FastOutLinearInEasing for a quick start and gradual slowdown, producing an initial bounce.
Mid-point Calculation:
midPointX and midPointY calculate a mid-point for the animation. midPointY is set to be above the initial position by 100.dp, creating an upward arc.
midBounds is created based on this calculated mid-point, maintaining the aspect ratio of the initial image.
midBounds at durationMillis * 0.4f using ArcMode.ArcAbove using FastOutLinearInEasing defines a keyframe at 40% of the total duration. The image will reach midBounds at this point, traveling with an upward curve (ArcMode.ArcAbove) and FastOutLinearInEasing.
targetBounds at durationMillis using overshootEasing: The animation concludes at the targetBounds (the detail image's position) at durationMillis (800 milliseconds). The overshootEasing is applied, creating the slightly elastic, overshooting effect as the image settles into place. 
How to implement
Replace R.drawable.my_image with your actual image resource.
Integrate within a SharedTransitionLayout: The example shows a basic setup. In a real application, you would typically integrate this within a navigation structure (e.g., using a NavHost and AnimatedContent) where the animatedVisibilityScope would be provided automatically.
Ensure Unique Keys: Each shared element requires a unique key using rememberSharedContentState(key = "...") to link them correctly across the transition.
Clickable Elements: Make sure both the initial and target shared elements are clickable to trigger the transition. 
By defining multiple keyframes with varying ArcMode values and custom Easing functions, you can create sophisticated and visually appealing shared element transitions that enhance the user experience and make your app feel more polished.


Shared Element Transitions in Jetpack Compose: A Deep Dive
Creating seamless and engaging user experiences is a cornerstone of modern mobile app development. One powerful tool in a developer's arsenal for achieving this is the shared element transition. This animation technique creates a visual connection between UI elements on different screens, guiding the user's eye and making navigation feel fluid and intuitive.[1][2] Previously a complex endeavor in Android development, Jetpack Compose now offers a streamlined and powerful set of APIs to implement these transitions with relative ease.
This deep dive will explore the ins and outs of shared element transitions in Jetpack Compose, from the fundamental concepts to practical implementation with code examples. We'll delve into the key APIs, explore different use cases, and provide the knowledge you need to start building visually stunning and user-friendly applications.
The "Why" Behind Shared Element Transitions
Shared element transitions are more than just eye candy. They serve a crucial purpose in user interface design by:
Maintaining Context: By smoothly animating a UI element from a source screen to its corresponding position on a destination screen, you help the user understand the relationship between the two.[1]
Guiding the User's Focus: The animation naturally draws the user's attention to the transformed element, highlighting its importance in the new context.[1]
Enhancing the Feeling of a Cohesive App: These transitions make the app feel more polished and integrated, as if the user is moving through a single, continuous space rather than jumping between disconnected screens.[1]
Core Concepts and Key APIs
As of Jetpack Compose UI version 1.7.0-alpha07, a new set of experimental APIs has been introduced to simplify the implementation of shared element transitions.[1] To get started, you'll need to ensure you're using a recent version of the Compose UI and Animation libraries in your build.gradle file.[1][3]
The primary components you'll be working with are:
SharedTransitionLayout: This composable acts as the root container for your shared element transitions. It provides a SharedTransitionScope, which is essential for the sharedElement and sharedBounds modifiers to function. You should place this at a high level in your UI hierarchy, encompassing all the screens that will participate in the transition.[4][5]
Modifier.sharedElement(): This modifier is the star of the show. You apply it to the composables that you want to share between screens. It takes a rememberSharedContentState which requires a unique key to identify the element across different composables, and an AnimatedVisibilityScope. This scope is typically provided by containers like AnimatedContent or a NavHost from the Navigation Compose library.[4][5]
Modifier.sharedBounds(): Similar to sharedElement(), this modifier is used to define a shared area for a transition. However, it's designed for scenarios where the content within the bounds is different between the start and end states. With sharedBounds(), both the entering and exiting content are visible during the transition, whereas sharedElement() only renders the target content.[2][4]
A Simple Implementation: Transitioning Between Two Composable States
Let's start with a basic example of a shared element transition within a single screen, using AnimatedContent to switch between a "summary" and a "detailed" view.
code
Kotlin
import androidx.compose.animation.AnimatedContent
import androidx.compose.animation.ExperimentalSharedTransitionApi
import androidx.compose.animation.SharedTransitionLayout
import androidx.compose.foundation.Image
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.material3.Text
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.unit.dp

@OptIn(ExperimentalSharedTransitionApi::class)
@Composable
fun SimpleSharedElementExample() {
    var showDetails by remember { mutableStateOf(false) }

    SharedTransitionLayout {
        AnimatedContent(
            targetState = showDetails,
            label = "sharedElementTransition"
        ) { isDetailsScreen ->
            if (!isDetailsScreen) {
                // Summary View
                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(16.dp)
                        .clickable { showDetails = true },
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Image(
                        painter = painterResource(id = R.drawable.ic_launcher_foreground),
                        contentDescription = null,
                        modifier = Modifier
                            .size(64.dp)
                            .sharedElement(
                                rememberSharedContentState(key = "image"),
                                animatedVisibilityScope = this@AnimatedContent
                            )
                    )
                    Spacer(modifier = Modifier.width(16.dp))
                    Text(
                        text = "A Shared Title",
                        modifier = Modifier
                            .sharedElement(
                                rememberSharedContentState(key = "title"),
                                animatedVisibilityScope = this@AnimatedContent
                            )
                    )
                }
            } else {
                // Detail View
                Column(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(16.dp)
                        .clickable { showDetails = false },
                    horizontalAlignment = Alignment.CenterHorizontally
                ) {
                    Image(
                        painter = painterResource(id = R.drawable.ic_launcher_foreground),
                        contentDescription = null,
                        modifier = Modifier
                            .size(200.dp)
                            .sharedElement(
                                rememberSharedContentState(key = "image"),
                                animatedVisibilityScope = this@AnimatedContent
                            )
                    )
                    Spacer(modifier = Modifier.height(16.dp))
                    Text(
                        text = "A Shared Title",
                        style = androidx.compose.material3.MaterialTheme.typography.headlineMedium,
                        modifier = Modifier
                            .sharedElement(
                                rememberSharedContentState(key = "title"),
                                animatedVisibilityScope = this@AnimatedContent
                            )
                    )
                    Text(text = "This is the detailed description of the item.")
                }
            }
        }
    }
}
In this example, both the Image and the Text in the Row and Column are marked with Modifier.sharedElement(). The key provided to rememberSharedContentState is crucial for the framework to know which elements to match between the two states. The AnimatedContent composable handles the transition between the summary and detail views automatically.
Integrating with Jetpack Navigation Compose
A common and highly effective use case for shared element transitions is navigating between a list and a detail screen. The new APIs are designed to work seamlessly with Navigation Compose.[1][6]
Here's how you can set up a list-to-detail transition:
1. Set up your Navigation:
First, ensure your NavHost is a child of SharedTransitionLayout. This provides the necessary scope for the transitions to work across different navigation destinations.[5]
code
Kotlin
@OptIn(ExperimentalSharedTransitionApi::class)
@Composable
fun AppNavigation() {
    val navController = rememberNavController()
    SharedTransitionLayout {
        NavHost(navController = navController, startDestination = "list") {
            composable("list") {
                ListScreen(
                    onItemClick = { itemId ->
                        navController.navigate("detail/$itemId")
                    },
                    animatedVisibilityScope = this
                )
            }
            composable("detail/{itemId}") { backStackEntry ->
                val itemId = backStackEntry.arguments?.getString("itemId")
                DetailScreen(
                    itemId = itemId,
                    animatedVisibilityScope = this
                )
            }
        }
    }
}
2. Modify your Screens:
In your list and detail screens, you'll need to accept the AnimatedVisibilityScope and the SharedTransitionScope (which you can access via a with block or by making your composable an extension function on SharedTransitionScope).
List Screen:
code
Kotlin
@OptIn(ExperimentalSharedTransitionApi::class)
@Composable
fun SharedTransitionScope.ListScreen(
    onItemClick: (String) -> Unit,
    animatedVisibilityScope: AnimatedVisibilityScope
) {
    LazyColumn {
        items(items) { item ->
            Row(modifier = Modifier.clickable { onItemClick(item.id) }) {
                Image(
                    /* ... */
                    modifier = Modifier
                        .size(80.dp)
                        .sharedElement(
                            rememberSharedContentState(key = "image/${item.id}"),
                            animatedVisibilityScope = animatedVisibilityScope
                        )
                )
                Text(
                    text = item.title,
                    modifier = Modifier
                        .sharedElement(
                            rememberSharedContentState(key = "title/${item.id}"),
                            animatedVisibilityScope = animatedVisibilityScope
                        )
                )
            }
        }
    }
}
Detail Screen:
code
Kotlin
@OptIn(ExperimentalSharedTransitionApi::class)
@Composable
fun SharedTransitionScope.DetailScreen(
    itemId: String?,
    animatedVisibilityScope: AnimatedVisibilityScope
) {
    val item = /* Get item details based on itemId */
    Column {
        Image(
            /* ... */
            modifier = Modifier
                .fillMaxWidth()
                .height(250.dp)
                .sharedElement(
                    rememberSharedContentState(key = "image/$itemId"),
                    animatedVisibilityScope = animatedVisibilityScope
                )
        )
        Text(
            text = item.title,
            style = MaterialTheme.typography.headlineLarge,
            modifier = Modifier
                .sharedElement(
                    rememberSharedContentState(key = "title/$itemId"),
                    animatedVisibilityScope = animatedVisibilityScope
                )
        )
        // ... other details
    }
}
By using the same unique key for the corresponding elements in both screens (e.g., "image/${item.id}"), Jetpack Compose will automatically animate the image and title from the list item to their final positions on the detail screen.[1]
Customizing Your Transitions
The shared element transition APIs offer several ways to customize the animation to fit your app's style. You can modify the boundsTransform parameter of Modifier.sharedElement() to provide a custom AnimationSpec.[7] This allows you to control aspects like the animation's duration, easing curve, and more.
code
Kotlin
.sharedElement(
    state = rememberSharedContentState(key = "image"),
    animatedVisibilityScope = this@AnimatedContent,
    boundsTransform = { _, _ ->
        spring(stiffness = Spring.StiffnessLow)
    }
)
For more advanced scenarios, such as text resizing, the skipToLookaheadSize() modifier can be useful. It lays out the composable using its target size from the beginning of the animation, preventing unwanted text reflowing during the transition.[2][5]
sharedElement vs. sharedBounds: When to Use Which
The choice between Modifier.sharedElement() and Modifier.sharedBounds() depends on the nature of the content you are transitioning.
Use Modifier.sharedElement() when the content itself is the same between the two states, and you want to smoothly transform its size and position. A typical example is an image that expands from a thumbnail to a full-screen view.[4]
Use Modifier.sharedBounds() when the container's area is shared, but the content within it changes. For instance, a card that transforms into a detailed view with different internal components. With sharedBounds, you'll see both the outgoing and incoming content fade in and out during the transition.[2][4]
Best Practices and Things to Keep in Mind
Unique Keys are Essential: The key provided to rememberSharedContentState is how Compose identifies matching elements. Ensure these keys are unique for each shared element to avoid unexpected behavior.[8]
Modifier Order Matters: The order of modifiers can affect the transition. It's generally recommended to place size and padding modifiers before the sharedElement or sharedBounds modifier.
Experimental APIs: Remember that these APIs are still experimental, which means they could change in future releases of Jetpack Compose. Keep an eye on the official documentation for any updates.[2]
Performance: While these animations are optimized, be mindful of performance, especially on lower-end devices. Test your transitions thoroughly to ensure they run smoothly.[8]
By leveraging the power of shared element transitions in Jetpack Compose, you can create more intuitive, engaging, and visually appealing Android applications that delight your users. With the simplified APIs now available, there's never been a better time to explore this exciting feature.



This deep dive will explore the comprehensive suite of animation APIs available in Jetpack Compose, complete with simple code examples, implementation guidance, and best practices to help you bring your user interfaces to life.
The Philosophy: State-Driven Animations
At its core, animation in Compose is state-driven. Instead of manually manipulating object properties over time, you define how a UI element should appear in different states. When the state changes, Compose automatically handles the transition between those states, creating a smooth animation.[3][4] This declarative approach simplifies code and reduces the potential for bugs.[1]
High-Level Animation APIs: The Easiest Way to Animate
For most common use cases, Jetpack Compose provides high-level APIs that are incredibly easy to use and cover a wide range of scenarios.
1. animate*AsState: Animating a Single Value
When you need to animate a single value like color, size, or alpha, the animate*AsState functions are your go-to solution.[5][6] You simply provide the target value, and Compose handles the rest.[7]
There are built-in functions for various data types:
animateFloatAsState
animateColorAsState
animateDpAsState
And many more for Size, Offset, Rect, etc.[5][6]
Example: Animating Corner Radius
code
Kotlin
var isRound by remember { mutableStateOf(false) }
val cornerRadius by animateDpAsState(
    targetValue = if (isRound) 50.dp else 0.dp,
    label = "cornerRadius"
)

Box(
    modifier = Modifier
        .size(100.dp)
        .clip(RoundedCornerShape(cornerRadius))
        .background(Color.Blue)
        .clickable { isRound = !isRound }
)
In this example, when the isRound state changes, the cornerRadius value smoothly animates between 0.dp and 50.dp, creating a transition from a square to a circle.
2. AnimatedVisibility: Animating Presence
To animate the appearance and disappearance of a composable, AnimatedVisibility is the perfect tool.[8][9] It gracefully handles entering and exiting animations.
Example: Fading an Element In and Out
code
Kotlin
var isVisible by remember { mutableStateOf(true) }

Column(horizontalAlignment = Alignment.CenterHorizontally) {
    AnimatedVisibility(visible = isVisible) {
        Image(
            painter = painterResource(id = R.drawable.my_image),
            contentDescription = "My Image"
        )
    }
    Button(onClick = { isVisible = !isVisible }) {
        Text(if (isVisible) "Hide" else "Show")
    }
}```

By default, `AnimatedVisibility` uses a fade-in and fade-out effect. You can customize this with `enter` and `exit` transitions like `slideInHorizontally`, `scaleIn`, `fadeOut`, and more.

#### 3. `animateContentSize`: Animating Size Changes

The `animateContentSize` modifier allows a composable to smoothly animate its size whenever the content within it changes. This is ideal for expandable cards or text sections.

**Example: An Expandable Text View**

```kotlin
var expanded by remember { mutableStateOf(false) }

Column(
    modifier = Modifier
        .padding(16.dp)
        .animateContentSize() // This is the magic!
        .clickable { expanded = !expanded }
) {
    Text(
        text = "Lorem ipsum dolor sit amet, consectetur adipiscing elit.",
        maxLines = if (expanded) Int.MAX_VALUE else 2
    )
}
When the text expands or collapses, the Column's size will animate smoothly. Note: The order of modifiers is important; place animateContentSize before any size-related modifiers like .size().
[13]
4. AnimatedContent: Animating Content Switches
When you need to switch between different composables, AnimatedContent provides a way to animate the transition. [14][15]It's perfect for things like animating a counter or switching between different UI states.
[16]
Example: An Animating Counter
code
Kotlin
@OptIn(ExperimentalAnimationApi::class)
@Composable
fun AnimatingCounter() {
    var count by remember { mutableStateOf(0) }

    Row {
        Button(onClick = { count-- }) { Text("-") }
        AnimatedContent(targetState = count, label = "counter") { targetCount ->
            Text(
                text = "$targetCount",
                style = MaterialTheme.typography.headlineMedium
            )
        }
        Button(onClick = { count++ }) { Text("+") }
    }
}
By default, AnimatedContent applies a fade and scale effect. You can fully customize the enter and exit animations using the transitionSpec parameter.
[14][16]
Advanced Animation APIs for More Control
When the high-level APIs don't offer enough flexibility, Compose provides lower-level options for more granular control.
5. updateTransition: Coordinating Multiple Animations
If you need to animate multiple values simultaneously based on a single state change, updateTransition is the right choice. [11][17]It creates a Transition object that can manage several child animations, ensuring they run in sync.
Example: Animating Size and Color Together
code
Kotlin
enum class BoxState { Collapsed, Expanded }
var boxState by remember { mutableStateOf(BoxState.Collapsed) }
val transition = updateTransition(targetState = boxState, label = "boxTransition")

val size by transition.animateDp(label = "size") { state ->
    if (state == BoxState.Expanded) 200.dp else 100.dp
}
val color by transition.animateColor(label = "color") { state ->
    if (state == BoxState.Expanded) Color.Green else Color.Blue
}

Box(
    modifier = Modifier
        .size(size)
        .background(color)
        .clickable {
            boxState = if (boxState == BoxState.Collapsed) BoxState.Expanded else BoxState.Collapsed
        }
)
This is more efficient than using multiple animate*AsState functions, as it groups all related animations under one managed transition.
[18]
6. rememberInfiniteTransition: Creating Looping Animations
For animations that need to run indefinitely, such as loading indicators or pulsating effects, use rememberInfiniteTransition.
[5][19][20]
Example: A Pulsating Alpha Effect
code
Kotlin
val infiniteTransition = rememberInfiniteTransition(label = "infiniteTransition")
val alpha by infiniteTransition.animateFloat(
    initialValue = 0.2f,
    targetValue = 1f,
    animationSpec = infiniteRepeatable(
        animation = tween(1000, easing = LinearEasing),
        repeatMode = RepeatMode.Reverse
    ),
    label = "alpha"
)

Box(
    modifier = Modifier
        .size(100.dp)
        .graphicsLayer { this.alpha = alpha }
        .background(Color.Red)
)
7. Animatable: The Powerhouse for Gestures and Coroutines
For the ultimate level of control, especially when integrating animations with gestures or launching them from coroutines, Animatable is the API to use. [21][22]It's a coroutine-based API that allows you to start animations, snap to values instantly, and even interrupt ongoing animations.
[21][22]
Example: Animating on Tap with Animatable
code
Kotlin
val color = remember { Animatable(Color.Gray) }
var ok by remember { mutableStateOf(true) }

LaunchedEffect(ok) {
    color.animateTo(if (ok) Color.Green else Color.Red)
}

Box(
    Modifier
        .size(100.dp)
        .background(color.value)
        .clickable { ok = !ok }
)
In this snippet, LaunchedEffect triggers a coroutine whenever the ok state changes, which in turn calls animateTo to smoothly transition the color.
Customizing the "How": AnimationSpec
Every animation API in Compose allows you to specify an AnimationSpec to customize its behavior. [23]This defines the physics and timing of the animation. The main types are:
tween: A duration-based animation that transitions between values over a specified time, often with an Easing curve (like FastOutSlowInEasing).
[7][23][24]* spring: A physics-based animation that creates a natural, bouncy effect. You can configure its dampingRatio and stiffness.
[23][25]* keyframes: Allows you to specify values at particular timestamps in the animation, giving you fine-grained control over complex sequences.
[23][24][25]* repeatable / infiniteRepeatable: Wraps another AnimationSpec to make it loop.
[23]
Best Practices for Effective Animations
Be Purposeful: Animations should serve a purpose, such as providing feedback or guiding the user, not just for decoration.
[1]* Choose the Right API: Use high-level APIs for simple cases and fall back to lower-level ones like updateTransition or Animatable when more control is needed.
[6]* Prioritize Performance: Use Modifier.graphicsLayer for animating properties like alpha, scale, and rotation, as it's more performant than triggering recomposition.
[15]* Test Thoroughly: Ensure your animations are smooth across a range of devices and screen refresh rates.
[1]
By mastering these powerful and flexible animation APIs, you can create dynamic, engaging, and polished UIs in Jetpack Compose that truly stand out.
Have you ever admired the beautiful animations when navigating between screens in apps like Instagram, Spotify, or Airbnb? Ever wondered how those smooth, delightful transitions happen? Well, the magic you're seeing is often the Shared Element Transition!

A few days ago, I experimented with Jetpack Compose to build a quick sample app demonstrating Shared Element Transitions without relying on external libraries. I shared a video snippet on LinkedIn, and many of you loved it! Today, let's dive deeper into how you can implement this magical experience yourself, purely with Compose, and understand what's happening under the hood.

Akshay Nandwana
Mar 25
🚀 Mastering Shared Element Transitions in Jetpack Compose! ✨

Imagine transitioning seamlessly between screens while keeping a visual connection between elements—think images, cards, or text.

🏗 1. 𝐒𝐡𝐚𝐫𝐞𝐝𝐓𝐫𝐚𝐧𝐬𝐢𝐭𝐢𝐨𝐧𝐋𝐚𝐲𝐨𝐮𝐭

🔹 SharedTransitionLayout provides a container for managing shared element transitions between comp…


5
2
LinkedIn Post

The Idea
Imagine an e-commerce app displaying a list of stylish shoes. When your user selects a shoe, the shoe image elegantly enlarges and transitions smoothly into the detail view. Let's break down how this happens step-by-step:

Implementing Shared Element Transitions (Compose-Only!)
🏗 1. SharedTransitionLayout

SharedTransitionLayout acts as a container that manages the shared element transitions between composables. It creates a transition scope, ensuring all shared elements animate seamlessly between screens:

SharedTransitionLayout {
    NavHost(navController = navController, startDestination = "list") {
       composable("list") { ListScreen() }
       composable("detail") { DetailScreen() }
    }
}
Internal Mechanics:

Captures the initial and final bounds (position and size) of UI elements.

Coordinates these bounds using Compose’s powerful recomposition mechanism, ensuring smooth transitions.

🎭 2. with(sharedTransitionScope)

Inside SharedTransitionLayout, you gain access to a powerful scope: sharedTransitionScope. This scope allows you to precisely define how transitions between bounds (positions and sizes of elements) will animate:

with(sharedTransitionScope) {
    val boundsTransform = BoundsTransform { initialBounds, targetBounds ->
        keyframes {
            durationMillis = 1000
            initialBounds at 0 using ArcMode.ArcBelow using FastOutSlowInEasing
            targetBounds at 1000
        }
    }
}
Detailed Explanation of BoundsTransform:

BoundsTransform calculates and animates transitions between two sets of bounds (positions and sizes of UI elements).

It uses interpolation to generate intermediate points smoothly transitioning from the initial state to the final state.

With keyframes, you explicitly define animation states at specific timestamps:

At 0 ms, the animation starts from the initial bounds and follows an ArcBelow path with an easing function FastOutSlowInEasing.

At 1000 ms, it reaches the final bounds precisely.

The arc calculation involves mathematical functions (trigonometry) to generate curved paths instead of straight lines, enhancing visual appeal.

🔗 3. .sharedElement Modifier

The .sharedElement() modifier is critical—it tells Compose exactly which UI element is shared across screens and should animate between them:

Image(
    painter = painterResource(shoe.imageRes),
    contentDescription = shoe.name,
    modifier = Modifier
        .sharedElement(
            rememberSharedContentState(key = "$KEY_BACKGROUND-$currentPage"),
            animatedVisibilityScope = animatedVisibilityScope,
            boundsTransform = boundsTransform
        )
)
Internal Mechanics:

Links UI components between screens by matching their state keys.

Tracks element position, size, and visibility, automatically managing recompositions and state updates.

🧠 4. rememberSharedContentState

This helper function, rememberSharedContentState, helps Compose uniquely track each shared element's transition state:

rememberSharedContentState(key = "$KEY_BACKGROUND-$currentPage")
Internal Mechanics:

Stores and retrieves transition states consistently, ensuring animations remain smooth even through recompositions or layout updates.

Provides stable references for efficient transition management.

🎬 5. animatedVisibilityScope

The animatedVisibilityScope manages visibility animations, ensuring smooth appearance and disappearance of elements:

.sharedElement(
    rememberSharedContentState(key = "${KEY_BACKGROUND}-$currentPage"),
    animatedVisibilityScope = animatedVisibilityScope,
    boundsTransform = boundsTransform
)
Internal Mechanics:

Controls opacity and visibility transitions, employing linear interpolation for smooth fading.

Ensures visual continuity and enhances user experience by reducing abrupt UI changes.

Why Does This Matter?
Shared Element Transitions significantly enhance user experience by providing visual continuity, making your app feel polished, professional, and delightful. It brings life to your interface, captivating your users and encouraging deeper engagement.

Want More Such Content?
Join my Substack community!

Type your email...
Subscribe
I'm continually sharing practical tutorials, tips, and insights from my Android development journey. Plus, we've launched a referral leaderboard to rewards our most active subscribers. Invite your friends, colleagues, and let's learn and grow together!

Share Android Engineers

Join our WhatsApp Channel to get regular updates

Try implementing this yourself, share your results, tag me, and let's spread the magic of Jetpack Compose together!


CompositionLocal is a powerful mechanism in Jetpack Compose that allows you to propagate values down the composition tree without having to pass them explicitly through every composable. This technique is similar to dependency injection and enables your UI to be more modular and maintainable.


Android Engineers
Android Engineers


Creating Stunning Glassmorphism Effects in Jetpack Compose
A Complete Guide
Akshay Nandwana
May 29, 2025


Glassmorphism has become one of the most sought-after design trends in modern UI development. Its translucent, frosted-glass aesthetic creates depth and visual hierarchy while maintaining a clean, modern appearance. But can you achieve these beautiful effects directly in Jetpack Compose without external libraries? The answer is absolutely yes!


What is Glassmorphism?
Glassmorphism is a design trend characterized by:

Semi-transparent backgrounds with blur effects

Subtle borders and highlights

Multi-layered depth perception

Frosted glass appearance

Vibrant background elements showing through

Popular apps like iOS Control Center, Windows 11, and many modern web applications use glassmorphism to create immersive user experiences.

The Challenge with Jetpack Compose
Unlike CSS, which has built-in backdrop-filter: blur() support, Jetpack Compose doesn't have native backdrop blur functionality. However, we can create convincing glassmorphism effects using clever combinations of:

Semi-transparent overlays

Gradient backgrounds

Border styling

Shadow effects

Strategic layering

Implementation: Step-by-Step Guide
Let's build a glassmorphism card component that you can use in your Android applications.

Basic Glassmorphism Card
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp

@Composable
fun GlassmorphismCard(
    modifier: Modifier = Modifier,
    content: @Composable ColumnScope.() -> Unit
) {
    val glassBrush = Brush.linearGradient(
        colors = listOf(
            Color.White.copy(alpha = 0.25f),
            Color.White.copy(alpha = 0.1f)
        )
    )
    
    Card(
        modifier = modifier
            .clip(RoundedCornerShape(20.dp))
            .background(glassBrush)
            .border(
                width = 1.dp,
                brush = Brush.linearGradient(
                    colors = listOf(
                        Color.White.copy(alpha = 0.4f),
                        Color.White.copy(alpha = 0.1f)
                    )
                ),
                shape = RoundedCornerShape(20.dp)
            ),
        colors = CardDefaults.cardColors(
            containerColor = Color.Transparent
        ),
        elevation = CardDefaults.cardElevation(
            defaultElevation = 8.dp
        )
    ) {
        Column(
            modifier = Modifier.padding(24.dp),
            content = content
        )
    }
}
Enhanced Glassmorphism with Multiple Effects
For a more sophisticated approach, here's an enhanced version with better visual effects:

@Composable
fun EnhancedGlassmorphismCard(
    modifier: Modifier = Modifier,
    content: @Composable ColumnScope.() -> Unit
) {
    Box(
        modifier = modifier
            .clip(RoundedCornerShape(24.dp))
    ) {
        // Background blur simulation
        Box(
            modifier = Modifier
                .matchParentSize()
                .background(
                    brush = Brush.radialGradient(
                        colors = listOf(
                            Color.White.copy(alpha = 0.3f),
                            Color.White.copy(alpha = 0.1f),
                            Color.White.copy(alpha = 0.05f)
                        )
                    )
                )
        )
        
        // Glass surface
        Card(
            modifier = Modifier
                .matchParentSize()
                .border(
                    width = 1.5dp,
                    brush = Brush.linearGradient(
                        colors = listOf(
                            Color.White.copy(alpha = 0.5f),
                            Color.White.copy(alpha = 0.1f),
                            Color.White.copy(alpha = 0.8f)
                        )
                    ),
                    shape = RoundedCornerShape(24.dp)
                ),
            colors = CardDefaults.cardColors(
                containerColor = Color.Transparent
            ),
            elevation = CardDefaults.cardElevation(
                defaultElevation = 12.dp
            )
        ) {
            Column(
                modifier = Modifier.padding(28.dp),
                content = content
            )
        }
    }
}
Complete Example with Background
Here's a full example showing glassmorphism cards over a colorful background:

@Composable
fun GlassmorphismDemo() {
    Box(
        modifier = Modifier
            .fillMaxSize()
            .background(
                brush = Brush.verticalGradient(
                    colors = listOf(
                        Color(0xFF667eea),
                        Color(0xFF764ba2),
                        Color(0xFFf093fb)
                    )
                )
            )
    ) {
        // Background decorative elements
        Box(
            modifier = Modifier
                .size(200.dp)
                .offset(x = (-50).dp, y = 100.dp)
                .clip(CircleShape)
                .background(Color.White.copy(alpha = 0.1f))
        )
        
        Box(
            modifier = Modifier
                .size(150.dp)
                .offset(x = 250.dp, y = 300.dp)
                .clip(CircleShape)
                .background(Color.Yellow.copy(alpha = 0.2f))
        )
        
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(24.dp),
            verticalArrangement = Arrangement.spacedBy(24.dp)
        ) {
            Spacer(modifier = Modifier.height(60.dp))
            
            // Profile Card
            EnhancedGlassmorphismCard(
                modifier = Modifier.fillMaxWidth()
            ) {
                Row(
                    verticalAlignment = Alignment.CenterVertically,
                    horizontalArrangement = Arrangement.spacedBy(16.dp)
                ) {
                    Box(
                        modifier = Modifier
                            .size(60.dp)
                            .clip(CircleShape)
                            .background(Color.White.copy(alpha = 0.3f)),
                        contentAlignment = Alignment.Center
                    ) {
                        Text(
                            text = "👨‍💻",
                            fontSize = 28.sp
                        )
                    }
                    
                    Column {
                        Text(
                            text = "John Developer",
                            fontSize = 20.sp,
                            fontWeight = FontWeight.Bold,
                            color = Color.White
                        )
                        Text(
                            text = "Android Engineer",
                            fontSize = 14.sp,
                            color = Color.White.copy(alpha = 0.8f)
                        )
                    }
                }
            }
            
            // Stats Card
            GlassmorphismCard(
                modifier = Modifier.fillMaxWidth()
            ) {
                Text(
                    text = "Statistics",
                    fontSize = 18.sp,
                    fontWeight = FontWeight.Bold,
                    color = Color.White,
                    modifier = Modifier.padding(bottom = 16.dp)
                )
                
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.SpaceEvenly
                ) {
                    StatItem("Projects", "24")
                    StatItem("Reviews", "4.8★")
                    StatItem("Experience", "5 Years")
                }
            }
        }
    }
}

@Composable
fun StatItem(label: String, value: String) {
    Column(
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Text(
            text = value,
            fontSize = 24.sp,
            fontWeight = FontWeight.Bold,
            color = Color.White
        )
        Text(
            text = label,
            fontSize = 12.sp,
            color = Color.White.copy(alpha = 0.7f)
        )
    }
}

Popular Apps Using Glassmorphism
Spotify: Now Playing overlay, playlist cards
Apple Music: Control widgets, artist pages
Instagram: Story overlays, camera filters UI
Banking Apps: Card displays, security overlays
Weather Apps: Current conditions overlays
Control Centers: iOS Control Center, Android Quick Settings

Production-Ready Implementation
1. Music Player Interface (Spotify-Style)
This example creates a music player with glassmorphism effects similar to popular streaming apps:

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun MusicPlayerGlass(
    currentSong: Song,
    isPlaying: Boolean,
    onPlayPause: () -> Unit,
    onNext: () -> Unit,
    onPrevious: () -> Unit,
    modifier: Modifier = Modifier
) {
    Box(
        modifier = modifier
            .fillMaxSize()
            .background(
                brush = Brush.verticalGradient(
                    colors = listOf(
                        Color(0xFF1DB954).copy(alpha = 0.8f), // Spotify green
                        Color(0xFF191414), // Spotify dark
                        Color(0xFF000000)
                    )
                )
            )
    ) {
        // Background album art with blur effect
        AsyncImage(
            model = currentSong.albumArtUrl,
            contentDescription = null,
            modifier = Modifier
                .fillMaxSize()
                .blur(20.dp)
                .alpha(0.3f),
            contentScale = ContentScale.Crop
        )
        
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(24.dp),
            verticalArrangement = Arrangement.SpaceBetween
        ) {
            // Top Controls (Back, More options)
            TopAppBar(
                title = { Text("Now Playing", color = Color.White) },
                navigationIcon = {
                    IconButton(onClick = { /* Handle back */ }) {
                        Icon(
                            Icons.Default.ArrowBack,
                            contentDescription = "Back",
                            tint = Color.White
                        )
                    }
                },
                actions = {
                    IconButton(onClick = { /* Handle more */ }) {
                        Icon(
                            Icons.Default.MoreVert,
                            contentDescription = "More",
                            tint = Color.White
                        )
                    }
                },
                colors = TopAppBarDefaults.topAppBarColors(
                    containerColor = Color.Transparent
                )
            )
            
            // Album Art Card with Glassmorphism
            GlassCard(
                modifier = Modifier
                    .size(320.dp)
                    .align(Alignment.CenterHorizontally)
            ) {
                AsyncImage(
                    model = currentSong.albumArtUrl,
                    contentDescription = "${currentSong.title} album art",
                    modifier = Modifier
                        .fillMaxSize()
                        .clip(RoundedCornerShape(16.dp)),
                    contentScale = ContentScale.Crop
                )
            }
            
            // Song Info with Glass Background
            GlassCard(
                modifier = Modifier.fillMaxWidth()
            ) {
                Column {
                    Text(
                        text = currentSong.title,
                        style = MaterialTheme.typography.headlineSmall,
                        color = Color.White,
                        fontWeight = FontWeight.Bold
                    )
                    Text(
                        text = currentSong.artist,
                        style = MaterialTheme.typography.bodyLarge,
                        color = Color.White.copy(alpha = 0.8f)
                    )
                    
                    Spacer(modifier = Modifier.height(16.dp))
                    
                    // Progress Bar
                    LinearProgressIndicator(
                        progress = currentSong.progress,
                        modifier = Modifier.fillMaxWidth(),
                        color = Color.White,
                        trackColor = Color.White.copy(alpha = 0.3f)
                    )
                    
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween
                    ) {
                        Text(
                            text = currentSong.currentTime,
                            color = Color.White.copy(alpha = 0.7f),
                            style = MaterialTheme.typography.bodySmall
                        )
                        Text(
                            text = currentSong.duration,
                            color = Color.White.copy(alpha = 0.7f),
                            style = MaterialTheme.typography.bodySmall
                        )
                    }
                }
            }
            
            // Control Buttons with Glass Effect
            GlassCard(
                modifier = Modifier.fillMaxWidth()
            ) {
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.SpaceEvenly,
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    IconButton(
                        onClick = onPrevious,
                        modifier = Modifier.size(48.dp)
                    ) {
                        Icon(
                            Icons.Default.SkipPrevious,
                            contentDescription = "Previous",
                            tint = Color.White,
                            modifier = Modifier.size(32.dp)
                        )
                    }
                    
                    // Play/Pause Button with Enhanced Glass Effect
                    FloatingActionButton(
                        onClick = onPlayPause,
                        modifier = Modifier.size(64.dp),
                        containerColor = Color.White.copy(alpha = 0.2f),
                        contentColor = Color.White
                    ) {
                        Icon(
                            if (isPlaying) Icons.Default.Pause else Icons.Default.PlayArrow,
                            contentDescription = if (isPlaying) "Pause" else "Play",
                            modifier = Modifier.size(32.dp)
                        )
                    }
                    
                    IconButton(
                        onClick = onNext,
                        modifier = Modifier.size(48.dp)
                    ) {
                        Icon(
                            Icons.Default.SkipNext,
                            contentDescription = "Next",
                            tint = Color.White,
                            modifier = Modifier.size(32.dp)
                        )
                    }
                }
            }
        }
    }
}
2. Banking App Card Display
Real banking apps use glassmorphism for card displays and security overlays:

@Composable
fun BankingCardGlass(
    card: CreditCard,
    onCardClick: () -> Unit,
    modifier: Modifier = Modifier
) {
    val cardGradient = when (card.type) {
        CardType.PLATINUM -> listOf(Color(0xFFE5E4E2), Color(0xFFC0C0C0))
        CardType.GOLD -> listOf(Color(0xFFFFD700), Color(0xFFFFA500))
        CardType.BLACK -> listOf(Color(0xFF2C2C2C), Color(0xFF000000))
        else -> listOf(Color(0xFF1976D2), Color(0xFF1565C0))
    }
    
    Card(
        modifier = modifier
            .fillMaxWidth()
            .height(200.dp)
            .clickable { onCardClick() },
        shape = RoundedCornerShape(16.dp),
        elevation = CardDefaults.cardElevation(defaultElevation = 12.dp)
    ) {
        Box(
            modifier = Modifier
                .fillMaxSize()
                .background(
                    brush = Brush.linearGradient(
                        colors = cardGradient.map { it.copy(alpha = 0.9f) }
                    )
                )
        ) {
            // Glass overlay effect
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .background(
                        brush = Brush.radialGradient(
                            colors = listOf(
                                Color.White.copy(alpha = 0.3f),
                                Color.White.copy(alpha = 0.1f),
                                Color.Transparent
                            ),
                            center = Offset(0.3f, 0.2f)
                        )
                    )
            )
            
            Column(
                modifier = Modifier.padding(24.dp)
            ) {
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.SpaceBetween,
                    verticalAlignment = Alignment.Top
                ) {
                    Column {
                        Text(
                            text = card.bankName,
                            color = Color.White,
                            style = MaterialTheme.typography.bodyMedium,
                            fontWeight = FontWeight.Bold
                        )
                        Text(
                            text = card.cardType,
                            color = Color.White.copy(alpha = 0.8f),
                            style = MaterialTheme.typography.bodySmall
                        )
                    }
                    
                    // Contactless payment icon
                    Icon(
                        painter = painterResource(R.drawable.ic_contactless),
                        contentDescription = "Contactless",
                        tint = Color.White.copy(alpha = 0.8f),
                        modifier = Modifier.size(32.dp)
                    )
                }
                
                Spacer(modifier = Modifier.weight(1f))
                
                // Card number with glassmorphism chip
                Row(
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    // EMV Chip
                    Box(
                        modifier = Modifier
                            .size(32.dp, 24.dp)
                            .clip(RoundedCornerShape(4.dp))
                            .background(
                                brush = Brush.linearGradient(
                                    colors = listOf(
                                        Color.White.copy(alpha = 0.4f),
                                        Color.White.copy(alpha = 0.2f)
                                    )
                                )
                            )
                            .border(
                                1.dp,
                                Color.White.copy(alpha = 0.3f),
                                RoundedCornerShape(4.dp)
                            )
                    )
                    
                    Spacer(modifier = Modifier.width(16.dp))
                    
                    Text(
                        text = card.maskedNumber,
                        color = Color.White,
                        style = MaterialTheme.typography.headlineSmall,
                        fontFamily = FontFamily.Monospace,
                        letterSpacing = 2.sp
                    )
                }
                
                Spacer(modifier = Modifier.height(16.dp))
                
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.SpaceBetween
                ) {
                    Column {
                        Text(
                            text = "VALID THRU",
                            color = Color.White.copy(alpha = 0.7f),
                            style = MaterialTheme.typography.labelSmall
                        )
                        Text(
                            text = card.expiryDate,
                            color = Color.White,
                            style = MaterialTheme.typography.bodyMedium,
                            fontFamily = FontFamily.Monospace
                        )
                    }
                    
                    Text(
                        text = card.holderName,
                        color = Color.White,
                        style = MaterialTheme.typography.bodyMedium,
                        fontWeight = FontWeight.Bold
                    )
                }
            }
        }
    }
}
3. Weather App Overlay (iOS Weather Style)
Weather apps commonly use glassmorphism for current conditions overlays:

@Composable
fun WeatherGlassOverlay(
    currentWeather: WeatherData,
    hourlyForecast: List<HourlyWeather>,
    modifier: Modifier = Modifier
) {
    Box(
        modifier = modifier.fillMaxSize()
    ) {
        // Background with weather-appropriate gradient
        Box(
            modifier = Modifier
                .fillMaxSize()
                .background(
                    brush = Brush.verticalGradient(
                        colors = currentWeather.backgroundColors
                    )
                )
        )
        
        // Animated background elements (clouds, rain, etc.)
        WeatherBackgroundAnimation(currentWeather.condition)
        
        LazyColumn(
            modifier = Modifier.fillMaxSize(),
            contentPadding = PaddingValues(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            item {
                // Location and current temp
                GlassCard(
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Column(
                        horizontalAlignment = Alignment.CenterHorizontally
                    ) {
                        Text(
                            text = currentWeather.location,
                            style = MaterialTheme.typography.headlineMedium,
                            color = Color.White,
                            textAlign = TextAlign.Center
                        )
                        
                        Text(
                            text = "${currentWeather.temperature}°",
                            style = MaterialTheme.typography.displayLarge,
                            color = Color.White,
                            fontWeight = FontWeight.Light
                        )
                        
                        Text(
                            text = currentWeather.condition,
                            style = MaterialTheme.typography.bodyLarge,
                            color = Color.White.copy(alpha = 0.8f)
                        )
                        
                        Text(
                            text = "H:${currentWeather.high}° L:${currentWeather.low}°",
                            style = MaterialTheme.typography.bodyMedium,
                            color = Color.White.copy(alpha = 0.8f)
                        )
                    }
                }
            }
            
            item {
                // Hourly forecast
                GlassCard(
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Column {
                        Text(
                            text = "HOURLY FORECAST",
                            style = MaterialTheme.typography.labelMedium,
                            color = Color.White.copy(alpha = 0.8f),
                            modifier = Modifier.padding(bottom = 12.dp)
                        )
                        
                        LazyRow(
                            horizontalArrangement = Arrangement.spacedBy(16.dp)
                        ) {
                            items(hourlyForecast) { hour ->
                                HourlyWeatherItem(hour)
                            }
                        }
                    }
                }
            }
            
            item {
                // Weather details grid
                GlassCard(
                    modifier = Modifier.fillMaxWidth()
                ) {
                    LazyVerticalGrid(
                        columns = GridCells.Fixed(2),
                        verticalArrangement = Arrangement.spacedBy(16.dp),
                        horizontalArrangement = Arrangement.spacedBy(16.dp),
                        modifier = Modifier.height(200.dp)
                    ) {
                        item {
                            WeatherDetailItem(
                                icon = Icons.Default.Visibility,
                                label = "VISIBILITY",
                                value = currentWeather.visibility
                            )
                        }
                        item {
                            WeatherDetailItem(
                                icon = Icons.Default.Air,
                                label = "WIND",
                                value = "${currentWeather.windSpeed} mph"
                            )
                        }
                        item {
                            WeatherDetailItem(
                                icon = Icons.Default.WaterDrop,
                                label = "HUMIDITY",
                                value = "${currentWeather.humidity}%"
                            )
                        }
                        item {
                            WeatherDetailItem(
                                icon = Icons.Default.Thermostat,
                                label = "FEELS LIKE",
                                value = "${currentWeather.feelsLike}°"
                            )
                        }
                    }
                }
            }
        }
    }
}

@Composable
fun WeatherDetailItem(
    icon: ImageVector,
    label: String,
    value: String
) {
    Column {
        Row(
            verticalAlignment = Alignment.CenterVertically
        ) {
            Icon(
                imageVector = icon,
                contentDescription = null,
                tint = Color.White.copy(alpha = 0.6f),
                modifier = Modifier.size(16.dp)
            )
            Spacer(modifier = Modifier.width(4.dp))
            Text(
                text = label,
                style = MaterialTheme.typography.labelSmall,
                color = Color.White.copy(alpha = 0.6f)
            )
        }
        Text(
            text = value,
            style = MaterialTheme.typography.headlineSmall,
            color = Color.White,
            fontWeight = FontWeight.Bold
        )
    }
}
4. Enhanced Glass Card Component
Here's the production-ready glass card component used in all examples:

@Composable
fun GlassCard(
    modifier: Modifier = Modifier,
    blur: Dp = 20.dp,
    cornerRadius: Dp = 16.dp,
    borderWidth: Dp = 1.dp,
    alpha: Float = 0.15f,
    content: @Composable ColumnScope.() -> Unit
) {
    Card(
        modifier = modifier
            .clip(RoundedCornerShape(cornerRadius))
            .background(
                brush = Brush.linearGradient(
                    colors = listOf(
                        Color.White.copy(alpha = alpha + 0.1f),
                        Color.White.copy(alpha = alpha)
                    ),
                    start = Offset(0f, 0f),
                    end = Offset(1000f, 1000f)
                )
            )
            .border(
                width = borderWidth,
                brush = Brush.linearGradient(
                    colors = listOf(
                        Color.White.copy(alpha = 0.4f),
                        Color.White.copy(alpha = 0.1f),
                        Color.White.copy(alpha = 0.6f)
                    )
                ),
                shape = RoundedCornerShape(cornerRadius)
            ),
        colors = CardDefaults.cardColors(
            containerColor = Color.Transparent
        ),
        elevation = CardDefaults.cardElevation(
            defaultElevation = 8.dp
        )
    ) {
        Column(
            modifier = Modifier.padding(20.dp),
            content = content
        )
    }
}
5. Data Classes for Examples
data class Song(
    val title: String,
    val artist: String,
    val albumArtUrl: String,
    val duration: String,
    val currentTime: String,
    val progress: Float
)

data class CreditCard(
    val bankName: String,
    val cardType: String,
    val type: CardType,
    val maskedNumber: String,
    val expiryDate: String,
    val holderName: String
)

enum class CardType {
    PLATINUM, GOLD, BLACK, STANDARD
}

data class WeatherData(
    val location: String,
    val temperature: Int,
    val condition: String,
    val high: Int,
    val low: Int,
    val visibility: String,
    val windSpeed: String,
    val humidity: Int,
    val feelsLike: Int,
    val backgroundColors: List<Color>
)

data class HourlyWeather(
    val time: String,
    val temperature: Int,
    val condition: String,
    val icon: String
)
6. Advanced Glass Effects with Animations
@Composable
fun AnimatedGlassCard(
    modifier: Modifier = Modifier,
    content: @Composable ColumnScope.() -> Unit
) {
    var isPressed by remember { mutableStateOf(false) }
    
    val animatedAlpha by animateFloatAsState(
        targetValue = if (isPressed) 0.3f else 0.15f,
        animationSpec = tween(300)
    )
    
    val animatedElevation by animateDpAsState(
        targetValue = if (isPressed) 4.dp else 12.dp,
        animationSpec = tween(300)
    )
    
    Card(
        modifier = modifier
            .clip(RoundedCornerShape(20.dp))
            .background(
                brush = Brush.linearGradient(
                    colors = listOf(
                        Color.White.copy(alpha = animatedAlpha + 0.1f),
                        Color.White.copy(alpha = animatedAlpha)
                    )
                )
            )
            .border(
                width = 1.5.dp,
                brush = Brush.linearGradient(
                    colors = listOf(
                        Color.White.copy(alpha = 0.5f),
                        Color.White.copy(alpha = 0.1f),
                        Color.White.copy(alpha = 0.8f)
                    )
                ),
                shape = RoundedCornerShape(20.dp)
            )
            .pointerInput(Unit) {
                detectTapGestures(
                    onPress = {
                        isPressed = true
                        tryAwaitRelease()
                        isPressed = false
                    }
                )
            },
        colors = CardDefaults.cardColors(
            containerColor = Color.Transparent
        ),
        elevation = CardDefaults.cardElevation(
            defaultElevation = animatedElevation
        )
    ) {
        Column(
            modifier = Modifier.padding(24.dp),
            content = content
        )
    }
}
Key Techniques Explained
1. Layered Transparency
We use multiple layers with different alpha values to simulate depth and the frosted glass effect.

2. Gradient Borders
Linear gradients on borders create the characteristic glass-like highlights and reflections.

3. Strategic Color Mixing
Combining white overlays with varying opacity levels creates the translucent appearance.

4. Elevation and Shadows
Card elevation adds depth and helps separate glass elements from the background.

Tips for Better Glassmorphism
Use Vibrant Backgrounds: Glassmorphism works best over colorful, dynamic backgrounds

Subtle Borders: Keep border opacity low (0.1-0.4) for authenticity

Proper Contrast: Ensure text remains readable over glass surfaces

Consistent Rounded Corners: Use consistent border radius values

Layer Thoughtfully: Don't overuse the effect - less is more

Performance Considerations & Optimization Tips
While our glassmorphism implementation is efficient, keep these points in mind:

Gradient calculations can impact performance on older devices

Use remember for complex brush calculations when possible

Consider providing a simplified version for low-end devices

Test thoroughly on various screen densities


1. Use Remember for Complex Calculations
@Composable
fun OptimizedGlassCard() {
    val glassBrush = remember {
        Brush.linearGradient(
            colors = listOf(
                Color.White.copy(alpha = 0.25f),
                Color.White.copy(alpha = 0.1f)
            )
        )
    }
    // Use glassBrush in your composable
}
2. Conditional Rendering for Low-End Devices
@Composable
fun AdaptiveGlassCard(
    content: @Composable ColumnScope.() -> Unit
) {
    val isHighPerformanceDevice = LocalContext.current
        .getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager
        .let { it.deviceConfigurationInfo.reqGlEsVersion >= 0x30000 }
    
    if (isHighPerformanceDevice) {
        EnhancedGlassCard(content = content)
    } else {
        SimpleGlassCard(content = content)
    }
}
3. Reusable Glass Theme
object GlassTheme {
    val lightGlass = GlassStyle(
        alpha = 0.15f,
        borderAlpha = 0.3f,
        cornerRadius = 16.dp
    )
    
    val heavyGlass = GlassStyle(
        alpha = 0.25f,
        borderAlpha = 0.5f,
        cornerRadius = 20.dp
    )
}

data class GlassStyle(
    val alpha: Float,
    val borderAlpha: Float,
    val cornerRadius: Dp
)
Integration with Popular Libraries
With Accompanist for System UI
@Composable
fun GlassActivity() {
    val systemUiController = rememberSystemUiController()
    
    LaunchedEffect(Unit) {
        systemUiController.setSystemBarsColor(
            color = Color.Transparent,
            darkIcons = false
        )
    }
    
    // Your glass UI content
}
With the Navigation Component
@Composable
fun GlassNavigation() {
    val navController = rememberNavController()
    
    NavHost(navController, startDestination = "music") {
        composable("music") {
            MusicPlayerGlass(/* parameters */)
        }
        composable("weather") {
            WeatherGlassOverlay(/* parameters */)
        }
    }
}
Advanced Variations
You can extend this approach to create:

Neumorphism hybrid effects by adjusting shadow directions

Animated glass surfaces using animateColorAsState

Interactive glass elements that respond to user touch

Contextual transparency that adapts to background colors

Conclusion
Creating glassmorphism effects in Jetpack Compose is not only possible but also highly customizable. While we don't have native backdrop blur support, the combination of gradients, transparency, and thoughtful layering produces convincing glass-like surfaces that enhance your app's visual appeal.

The techniques shown here provide a solid foundation for implementing glassmorphism in your Android applications. Experiment with different gradient combinations, opacity levels, and border styles to create unique glass effects that match your app's design language.

Remember, glassmorphism is most effective when used sparingly as an accent rather than the primary design pattern throughout your entire application.

Have you implemented glassmorphism in your Jetpack Compose projects? Share your experiences and variations in the comments below! For more Android development tips and tutorials, follow me for regular updates.

Android Engineers
Android Engineers


Map vs FlatMap in Kotlin
Akshay Nandwana
Jan 24, 2025


When working with collections or streams of data in Kotlin, you may come across two frequently used higher-order functions: map and flatMap. Although they seem similar, they serve distinct purposes.

In this blog, we will explore the differences between these two functions, their use cases, and how to apply them in real-world scenarios.

Join our upcoming 6 Weeks Android Mentorship Program

Complete Syllabus

What is map?
The map function is used to transform each element in a collection into a new value by applying a given function. It returns a new collection where each element is the result of the transformation.

Syntax:
inline fun <T, R> Iterable<T>.map(transform: (T) -> R): List<R>
Example:
fun main() {
    val numbers = listOf(1, 2, 3, 4, 5)
    val squaredNumbers = numbers.map { it * it }

    println(squaredNumbers) // Output: [1, 4, 9, 16, 25]
}
Here, the map function transforms each number in the list into its square.

What is flatMap?
The flatMap function is a combination of map and flatten. It applies a transformation function to each element of a collection and then flattens the resulting collections into a single collection.

Syntax:
inline fun <T, R> Iterable<T>.flatMap(transform: (T) -> Iterable<R>): List<R>
Example:
fun main() {
    val numbers = listOf(1, 2, 3)
    val multipliedLists = numbers.flatMap { num -> listOf(num, num * 2, num * 3) }

    println(multipliedLists) // Output: [1, 2, 3, 2, 4, 6, 3, 6, 9]
}
In this example, flatMap transforms each number into a list of its multiples and then flattens those lists into a single list.

Key Differences Between map and flatMap
map

Transformation - Transforms elements individually

Output Structure - Nested structure allowed

Use Case - Simple transformations

flatMap

Transformation - Transforms elements and flattens the result

Output Structure - Always a single flattened structure

Use Case - Handling collections of collections

Real-World Examples
Example 1: Parsing JSON Response
Suppose you are working with an API response that contains a list of users, and each user has a list of hobbies. You want to extract all hobbies into a single list.

Using flatMap:

data class User(val name: String, val hobbies: List<String>)

fun main() {
    val users = listOf(
        User("Alice", listOf("Reading", "Hiking")),
        User("Bob", listOf("Gaming", "Cooking")),
        User("Charlie", listOf("Swimming", "Cycling"))
    )

    val allHobbies = users.flatMap { it.hobbies }

    println(allHobbies) // Output: [Reading, Hiking, Gaming, Cooking, Swimming, Cycling]
}
Here, flatMap flattens the nested structure of hobbies into a single list.

Example 2: Transforming Data for Analytics
Imagine you have a list of orders, and each order contains multiple items. You need a list of all items across all orders.

Using flatMap:

data class Order(val id: Int, val items: List<String>)

fun main() {
    val orders = listOf(
        Order(1, listOf("Laptop", "Mouse")),
        Order(2, listOf("Phone", "Charger")),
        Order(3, listOf("Desk", "Chair"))
    )

    val allItems = orders.flatMap { it.items }

    println(allItems) // Output: [Laptop, Mouse, Phone, Charger, Desk, Chair]
}
Example 3: Applying Discounts
Suppose you have a list of product categories, and each category contains a list of products with prices. You want to apply a 10% discount to all products and get a flat list of discounted prices.

Using flatMap:

data class Product(val name: String, val price: Double)

data class Category(val name: String, val products: List<Product>)

fun main() {
    val categories = listOf(
        Category("Electronics", listOf(Product("TV", 500.0), Product("Radio", 100.0))),
        Category("Furniture", listOf(Product("Sofa", 300.0), Product("Table", 150.0)))
    )

    val discountedPrices = categories.flatMap { category ->
        category.products.map { it.price * 0.9 } // Apply 10% discount
    }

    println(discountedPrices) // Output: [450.0, 90.0, 270.0, 135.0]
}
When to Use map and flatMap
Use map when you need to transform individual elements without flattening.

Use flatMap when you need to transform elements and flatten nested structures.

Conclusion
Understanding the difference between map and flatMap is crucial for writing concise and efficient Kotlin code. While map is ideal for straightforward transformations, flatMap shines when working with collections of collections. By mastering these functions, you can handle complex data transformations with ease.

Start experimenting with map and flatMap in your Kotlin projects today to unlock their full potential!

In this article, we'll embark on an exciting journey to implement the GlassmorphicLayer component in Jetpack Compose. Get ready, because we're about to transform your UI from basic to sleek!

What is Glassmorphism, and Why Should You Care?
Before we dive into the code, let's talk about what glassmorphism is and why it's causing such a buzz in the design world. Glassmorphism is a design trend that creates a frosted glass effect in user interfaces. It typically involves:

A semi-transparent background

A subtle blur effect

Light borders or shadows to create depth

Glassmorphism can give your app a:

Modern and sleek look

More depth and layered

Visually interesting without being overwhelming

Plus, it's a great way to make your app stand out in a sea of flat designs!

Setting the Stage: The GlassmorphicLayer Component
Now that we know what we're aiming for, let's introduce the star of our show: the GlassmorphicLayer component. This nifty piece of Jetpack Compose magic will allow us to create stunning glassmorphic effects with ease.

Here's a sneak peek at what we'll be working with:


Copy

Copy
@Composable
fun GlassmorphicLayer(
    modifier: Modifier = Modifier,
    backgroundDimColor: Color = Color.Transparent,
    transitionStiffness: Float = Spring.StiffnessMediumLow,
    blurSourceView: View = LocalView.current.rootView.findViewById(android.R.id.content),
    contentEnterAnimation: EnterTransition = getDefaultEnterAnimation(transitionStiffness),
    contentExitAnimation: ExitTransition = getDefaultExitAnimation(transitionStiffness),
    onDismissRequest: () -> Unit,
    content: @Composable BoxScope.() -> Unit,
) {
    // The magic happens here!
}
Don't worry if this looks intimidating – we'll break it down step by step!

The Journey Begins: Understanding the Components
Our journey to glassmorphic greatness involves three main parts:

The main GlassmorphicLayer component

A helper component called ScreenContentGlassmorphedLayer

A custom Modifier extension named glassmorph()

Let's explore each of these:

1. GlassmorphicLayer: The Conductor of Our Glassmorphic Orchestra
This is the main component you'll use in your app. Think of it as the conductor of an orchestra, harmonizing all elements to achieve a cohesive glassmorphic effect.

Key responsibilities:

Managing the visibility of the glass effect and content

Handling animations

Coordinating the blur effect

2. ScreenContentGlassmorphedLayer: The Background Artist
This behind-the-scenes component creates the blurred background that gives our glassmorphic effect its signature look.

What it does:

Captures a snapshot of your app's current view

Applies a blur effect to this snapshot

Displays the blurred image with smooth animations

3. glassmorph() Modifier: The Special Effects Wizard
This custom Modifier extension is where the real magic happens. It applies the blur effect and handles the animations that make our glassmorphic layer come to life.

Its superpowers:

Animating the blur radius

Controlling the visibility of the blur effect

The Implementation Adventure: A Step-by-Step Guide
Now that we know the key players, let's walk through how to implement the GlassmorphicLayer in your app. Don't worry; we'll take it one step at a time!

Step 1: Set Up Your Project
Ensure Jetpack Compose is set up in your Android project. If you haven't done this yet, check out the official Jetpack Compose documentation for guidance.

Step 2: Import the GlassmorphicLayer
Add this import statement at the top of your Kotlin file:


Copy

Copy
import com.design.components.GlassmorphicLayer
Step 3: Use GlassmorphicLayer in Your Composable
Here's a simple example of how to use the GlassmorphicLayer:


Copy

Copy
@Composable
fun MyGlassmorphicScreen() {
    GlassmorphicLayer(
        backgroundDimColor = Color.Black.copy(alpha = 0.5f),
        onDismissRequest = { showGlass = false }
    ) {
        // Content inside the glassmorphic layer
        Text(
            text = "Glassmorphic Content",
            modifier = Modifier.align(Alignment.Center)
        )
    }
}
This example shows a glassmorphic layer on top of the current screen content with some text inside. Cool, right?

Customization: Making It Your Own
Now that we have our glassmorphic layer up and running, let's explore some ways to customize it and make it truly yours!

1. Change the Background Dim
Want to set the mood? Adjust the backgroundDimColor:


Copy

Copy
backgroundDimColor = Color.Blue.copy(alpha = 0.3f)
2. Tweak the Animation Speed
Make it snappy or smooth by modifying transitionStiffness:


Copy

Copy
transitionStiffness = Spring.StiffnessHigh // for faster animations
3. Create Custom Animations
Want your glassmorphic layer to make a grand entrance? Provide your own enter and exit animations:


Copy

Copy
contentEnterAnimation = slideInVertically() + fadeIn()
contentExitAnimation = slideOutVertically() + fadeOut()
4. Blur a Specific View
Get focused by blurring a specific view instead of the whole screen:


Copy

Copy
blurSourceView = myCustomView
The Secret Sauce: Implementing the Blur Effect
Now, let's dive into the heart of our glassmorphic effect: the blur implementation. This is where things get really interesting!

Blurring Across Android Versions
One of the challenges in implementing a consistent glassmorphic effect is dealing with different Android versions. Our GlassmorphicLayer component handles this elegantly:

On Android 12 and above: We use the blur modifier directly on the current view snapshot.

On lower Android versions: We apply the blurring on the snapshot bitmap itself.

Let's break this down step by step:

Step 1: Capturing the View as a Bitmap
First, we need to capture our current view as a bitmap. Here's how we do it:


Copy

Copy
fun View.captureViewAsBitmap(callback: (Bitmap?) -> Unit) {
    val window = context.findActivity()?.window
    if (window == null) {
        callback(null)
    } else {
        captureViewAsBitmap(window, callback)
    }
}

fun View.captureViewAsBitmap(
    window: Window,
    callback: (Bitmap?) -> Unit,
) {
    val bitmap =
        Bitmap.createBitmap(
            // The width of the view to be captured
            width,
            // The height of the view to be captured
            height,
            // The bitmap configuration (32-bit color with alpha)
            Bitmap.Config.ARGB_8888,
        )
    val location = IntArray(2)
    // Gets the location of the view within the window
    getLocationInWindow(location)
    val bounds =
        Rect(
            location[0], // Left bound
            location[1], // Top bound
            location[0] + width, // Right bound
            location[1] + height, // Bottom bound
        )
    runCatching {
        PixelCopy.request(
            window,
            bounds,
            bitmap,
            {
                when (it) {
                    // Capture succeeded
                    PixelCopy.SUCCESS -> callback(bitmap)
                    // Capture failed
                    else -> callback(null)
                }
            },
            // Ensures the callback is handled on the main thread
            Handler(Looper.getMainLooper()),
        )
    }.onFailure {
        // Fallback to return null in case of failure
        callback(null)
    }
}
This function uses a neat trick to find the associated Activity and its window, then captures the view's content as a bitmap.

Step 2: Applying the Blur Effect
Now comes the magic part - applying the blur effect. For Android versions below 12, we use a custom blur function:


Copy

Copy
fun Bitmap.blur(context: Context, radius: Float = 25F): Bitmap {
    // Ensure the blur radius is within the valid range (1 to 25)
    val radiusResolved = radius.coerceIn(1f, 25f)

    // Scale down the bitmap for better performance
    val blurScale = 0.1F
    val blurWidth = (width * blurScale).roundToInt()
    val blurHeight = (height * blurScale).roundToInt()
    val inputBitmap = Bitmap.createScaledBitmap(this, blurWidth, blurHeight, false)

    // Apply the blur using RenderScript
    val renderScript = RenderScript.create(context)
    val intrinsic = ScriptIntrinsicBlur.create(renderScript, Element.U8_4(renderScript))
    val allocationInput = Allocation.createFromBitmap(renderScript, inputBitmap)
    val allocationOutput = Allocation.createFromBitmap(renderScript, inputBitmap)

    intrinsic.setRadius(radiusResolved)
    intrinsic.setInput(allocationInput)
    intrinsic.forEach(allocationOutput)

    allocationOutput.copyTo(inputBitmap)

    // Scale the bitmap back up to the original size
    return Bitmap.createScaledBitmap(inputBitmap, width, height, false)
}
This function does a few cool things:

It scales down the bitmap for better performance.

Applies the blur using RenderScript (a high-performance runtime that provides computationally intensive operations).

Scales the bitmap back up to its original size.

The Glassmorphic Magic Revealed
Now, let's see how we tie this all together in our glassmorph modifier:


Copy

Copy
@Composable
private fun Modifier.glassmorph(
    transitionStiffness: Float,
    visibilityState: State<Boolean>,
): Modifier {
    val blur by animateDpAsState(
        targetValue = if (visibilityState.value) 60.dp else 0.dp,
        animationSpec = spring(stiffness = transitionStiffness),
        label = "glassmorphic effect",
    )
    return this.blur(
        radius = blur,
    )
}
This modifier does something really clever:

For Android 12 and above, it uses the built-in blur modifier.

For older versions, it captures the view as a bitmap, applies our custom blur function, and then draws the blurred bitmap on top of the original content.

Why This Approach Rocks
Compatibility: It works across different Android versions, ensuring a consistent look for all users.

Performance: By scaling down the bitmap before blurring, we keep things smooth and snappy.

Customizability: The blur radius is animated, allowing for smooth transitions.

Putting It All Together
When you use the GlassmorphicLayer in your app, all this complexity is handled for you behind the scenes. You get a beautiful, performant glassmorphic effect without having to worry about the nitty-gritty details of bitmap manipulation or version-specific implementations.

Challenges Along the Way (and How to Overcome Them)
As with any journey, you might encounter some bumps in the road. Here are some common challenges and how to overcome them:

1. Performance Issues
Challenge: The blur effect might be slow on older devices.

Solution: Use a lower blur radius or disable the effect for low-end devices.


Copy

Copy
val blurRadius = if (isLowEndDevice()) 0.dp else 10.dp
2. Content Visibility
Challenge: Text might be hard to read on the blurred background.

Solution: Add a semi-opaque background to your content or increase text contrast.


Copy

Copy
Text(
    "Glassmorphic Content",
    modifier = Modifier
        .background(Color.White.copy(alpha = 0.7f))
        .padding(16.dp),
    color = Color.Black
)
3. Inconsistent Look
Challenge: The effect looks different on various devices.

Solution: Test across devices and adjust blur/transparency for consistency.

Best Practices for Your Glassmorphic Journey
As you continue to explore and implement glassmorphic effects in your app, keep these best practices in mind:

Start Simple: Begin with the basic implementation before adding complex customizations.

Test Frequently: Check your UI on different devices and screen sizes.

Performance Matters: Be mindful of performance, especially on lower-end devices.

Accessibility: Ensure your glassmorphic UI is accessible to all users.

Consistent Design: Use the effect consistently throughout your app for a cohesive look.

Wrapping Up: Your Glassmorphic Adventure Awaits!
Congratulations! You've now embarked on the exciting journey of implementing the GlassmorphicLayer in Jetpack Compose. With this powerful tool in your arsenal, you're ready to create stunning, modern UIs that will captivate your users.

Remember, the key to mastering any new technique is practice. So go forth and experiment! Try implementing the GlassmorphicLayer in different parts of your app, play with customizations, and most importantly, have fun with it!

Who knows? Your next app could be the standout with its sleek glassmorphic UI. Happy coding, and may your interfaces always be as smooth as frosted glass!

Google introduced Shared Element Transitions for Jetpack Compose at their 2024 I/O event!

The Shared Element Transition API provides a way to create smooth and visually appealing transitions between composables that share the same UI element. This helps maintain visual continuity and improves the user experience, especially when navigating different screens.

For example, imagine a user taps on a photo in a list, and instead of jumping to a new screen, the photo smoothly expands to fill the screen which creates a great user experience. Previously, creating such effects in Jetpack Compose required complex code. Now, Google has streamlined this process, making it much simpler to achieve.

In this article, we’ll explore Shared Element Transitions and its key elements and show you how to set them up with clear examples. In Part 2, we’ll cover how to customise them for your app to create interactive user experiences.

Experimental: Shared element support is available from Compose 1.7.0-beta01 and is experimental, the APIs may change in future.

Key Elements
In Jetpack Compose, there are a few high-level APIs that facilitate the creation of shared element transitions:

SharedTransitionLayout
It is a special layout required when creating shared element transitions in Jetpack Compose.
It provides a SharedTransitionScope, which is essential for the elements that participate in the transition.
2. Modifier.sharedElement()

It marks a composable (UI element) as one that should be linked with another composable for a transition.
It instructs the SharedTransitionScope to match this element with its corresponding element in the transition.
3. Modifier.sharedBounds()

It is used when you want a composable’s boundaries (size and position) to define the area for the transition.
Unlike sharedElement(), this modifier is for cases where the content inside the transitioning elements might differ, but they still need to transition together.
SharedBounds Vs SharedElement
Modifier.sharedBounds() is similar to Modifier.sharedElement(). However, the modifiers are different in the following ways:

sharedBounds() is for content that is visually different but should share the same area between states, whereas sharedElement() expects the content to be the same.
With sharedBounds(), the content entering and exiting the screen is visible during the transition between the two states, whereas with sharedElement() , only the target content is rendered in the transforming bounds.
Required Dependencies
To use the new Shared Element Transition APIs, ensure you are using the latest version of Jetpack Compose UI and animation libraries. Below is an example of adding the required dependencies:

Always refer to the official documentation to verify and use the latest versions.

Creating a Sample Implementation with Shared Element Transitions
Let’s begin our sample implementation with the navigation setup.

Defining Screens

This code defines a sealed class named Screen to manage navigation. It includes two screens: AlbumsScreen, with a static route "list", and AlbumDetailsScreen, with a dynamic route "details/{albumId}". The createRoute function in AlbumDetailsScreen generates a specific route based on the album ID.

Defining Album Model

It defines a data class named Album, which models an album with properties such as ID, title, author, release year, and a drawable resource ID for the album cover.

Setting Up AnimationSpec

This code makes an animation last 500 milliseconds (or half a second). The albumBoundsTransform function describes how to smoothly move a shared element from its starting position to its ending position during this time.

Setting Up MainContent

The outermost layer of your composables must be SharedTransitionLayout. This layout is used to connect the two screens, AlbumsScreen and AlbumDetailScreen, using the Jetpack Compose navigation framework.

With this setup, our navigation is ready to handle transitions between the two screens. The SharedTransitionScope is available within these screens, enabling shared element transitions.

Note at this point that the sharedElement modifier is only available within the SharedTransitionScope scope provided by SharedTransitionLayout so we need to ensure the scope is available to the AlbumsScreen composable; we could either pass the scope as an argument and then wrap the composable with a with(scope) or, alternatively, we can make the AlbumsScreen composable an extension function on SharedTransitionScope.

Implementing AlbumsScreen

Here, we are going to see the implementation for AlbumsScreen and shared element transition, for detailed UI implementation.

In the above code, we have taken LazyVerticalGrid with two columns, where all the albums are aligned in the Grid. We have applied the sharedElement modifier on each AlbumItem click.

To enable shared element transition, we used Modifier.sharedElement() API that takes three parameters an AnimatedVisibilityScope, rememberSharedContentState() and boundsTransform.

The AnimatedVisibilityScope is the scope for the content of AnimatedVisibility. In this scope, direct and indirect children of AnimatedVisibility will be able to define their own enter/ exit transitions using the built-in options via a custom function Modifier. animateEnterExit. You can go through more about AnimatedVisibility from its official documentation.

The rememberSharedContentState(), is the important parameter that helps in shared element transition, ensuring that the transition is applied consistently across screens. This function remembers a SharedContentState object, which stores a unique key that determines which elements are shared.

The boundsTransformation defines the animation spec used to animate from initial bounds to the target bounds.

Implementing AlbumItem

Here, we are going to see the implementation of AlbumItem composable which contains the Image of the album and adds a shared element transition effect.

That’s all we need to do for the AlbumsScreen to achieve the shared element transition. Next, we will see the implementation of AlbumDetailScreen.

Implementing AlbumDetailScreen

In this screen, we will be applying the same keyed sharedElement() in our composable so that transition is applied for that particular item.

The AlbumDetailScreen is mainly divided into three composables: AlbumDetailHeader, AlbumDetailInfo and AlbumDetailDescription.

AlbumDetailHeader
Here, the AlbumDetailHeader composable contains a cover image of the album with the back button.

2. AlbumDetailInfo

Here, the AlbumDetailInfo composable contains album details like title, author, year & play button, etc.

3. AlbumDetailDescription

Here, the AlbumDetailDescription composable contains a detailed description of the album.

4. InformationPanel

Here, the InformationPanel composable contains an album description.

We used the skipToLookaheadSize() function of the shared element transition for the text. By default, when transitioning between two layouts, the layout size animates between its start and final state. This may be undesirable behaviour when animating content such as text.

So basically, skipToLookaheadSize() prevents the reflowing of the text and keeps its final state at the start of the animation.

With this setup, we are finally done with the implementation of shared element transition in compose with navigation!


You can find the complete code of the above sample demo on GitHub.

Conclusion
Shared Element Transitions in Jetpack Compose streamline creating smooth, visually connected animations between screens. With straightforward setup and customisation, these transitions help create a polished and engaging app design, making navigation feel smooth and natural.

we explored the shared element transition API and used it to create a functional demo showing an album list transitioning into a detailed album view.

In this article, we will understand how we can customise the shared element transition API and provide a more interactive and impressive user experience.

A few parameters can be used to customise the shared element transition API:

Animation Spec
Animated Visibility
1. Animation Spec
To create a more dynamic and visual transition, we can customise the animation behaviour for size and position changes.

By specifying a different boundsTransform parameter on Modifier.sharedElement() where we can control the initial and target Rect positions.

For example, to make the text move with an arc motion, simply set the boundsTransform parameter to use a keyframe spec, adding a touch of elegance to your transition animation.

Creating a Text Transform Animation with Shared Element Transition API
Let’s begin implementing text transform animation with animation spec customisation.

Setting up AnimationSpec

textBoundsTransform
The BoundsTransform is used in shared element transitions to smoothly animate between the starting and ending positions of an element.

It uses a tween animation, which you can control with durationMillis to set how long the animation lasts.

The FastOutSlowInEasing adds a natural, smooth motion, making the transition between UI components look seamless.

animatedTextBoundsTransform
The animatedTextBoundsTransform uses a keyframes-based animation to smoothly move text elements from their starting position to their final position.

It defines how the text moves over time, beginning with the initialBounds and ending with the targetBounds.

By using ArcMode.ArcBelow and FastOutSlowInEasing, the movement follows a curved path with a smooth, visually pleasing effect. This creates a dynamic transition specifically designed for text elements.

textEnterAnimation
The textEnterAnimation creates a fade-in effect for a Text component as it enters the screen.

The animation lasts for a specified duration, using the FastOutSlowInEasing function to start quickly and gradually slow down, resulting in a smooth and visually appealing transition.

textExitAnimation
The textExitAnimation applies a fade-out effect to a Text component as it exits the screen.

It matches the fade-in animation in duration and uses the same FastOutSlowInEasing function, ensuring a consistent and smooth animation style for both entering and exiting transitions.

Setting up MainContent

The outermost layer of your composables must be SharedTransitionLayout.

It mainly involves opening and closing the details screen using the showDetails state variable, which changes based on two lambda functions: showDetails() and onBack().

The sharedBoundsModifier in the MainContent composable is used to manage the shared element transition between different content states. Here’s a breakdown of its components:

sharedBounds: This is a modifier function that integrates shared element transitions. It helps animate the bounds of a UI element between different states.
sharedContentState: rememberSharedContentState(key = "bounds") creates and remembers the state of the shared content bounds using a unique key. This state is used to track the position and size of the shared element.
animatedVisibilityScope: This is the scope provided by AnimatedContent, which allows the sharedBoundsModifier to apply animations to the shared element within this scope.
enter and exit animations: textEnterAnimation and textExitAnimation define how the shared element should animate when it enters or exits the screen.
boundsTransform: textBoundsTransform specifies how the bounds of the shared element should transition between the initial and target states, using tween animation for smooth changes.
In summary, sharedBoundsModifier ensures that the element’s position and size are animated smoothly when transitioning between different content states, maintaining visual continuity during the transition.

Implementing CarScreen

Here, we will see the implementation of Car composable, which contains an image and the car's name. We have applied the sharedElement modifier on both components.

Implementing CarDetailsScreen

Here, we will see the implementation of CarDetails composable, which contains an image, name, and description of the car.

In the above code, we have used sharedBounds() modifier on text because we need to change the position of the text during transition animation.

That’s all we need to do for text transform animation.


You can find the complete code of the above sample demo on GitHub.

2. Animated Visibility
Shared Element Transition also works with animated visibility, both shared element and bounds modifier.

For example, whenever the item in a list is clicked on, the content has the visual effect of being pulled out of the UI into a dialog-like component. We can achieve this kind of animation using this API.

Creating a Shared Element Transition Animation with Animated Visibility
Let’s begin the implementation of shared element transition animation with Animated Visibility customisation.

Setting up AnimationSpec

It defines a constant ANIMATION_DURATION_IN_MILLIS set to 200 milliseconds and a dessertBoundsTransition using a BoundsTransform.

The sharedElementTransitionSpec function provides a tween animation specification, which can be used for shared element transitions, with a duration of 200 milliseconds.

Defining Dessert Model

It defines a data class named Dessert, which represents a dessert item with three properties: an id (as an Int), a name (as a string) and an image (as a drawable resource ID annotated with @DrawableRes).

Defining Screens

This code defines a sealed class named Screen to manage navigation. It includes two screens: DessertsScreen, with a static route "list", and DessertDetailsScreen, with a dynamic route "details/{dessertId}". The createRoute function in DessertDetailsScreen generates a specific route based on the dessert ID.

Setting Up TransitionAnimatedVisibilityScreen Composable

Here, we are going to see the implementation TransitionAnimated VisibilityScreen composable, which contains Scaffold implementation and a list of desserts.

Setting Up MainContent

The outermost layer of your composables must be SharedTransitionLayout. This layout is used to connect the two screens, DessertsScreen and DessertDetailScreen, using the Jetpack Compose navigation framework.

Implementing DessertsScreen

Here, we are going to see the implementation of the DessertsScreen composable, which contains a list of desserts.

The above code defines a dessert item with a custom transition effect, making it appear and disappear smoothly using shared element transitions. The transition includes animations for both the bounds (size and position) and the individual elements (e.g., name and image) within the dessert item.

Implementing DessertContents

Here, we are going to see the implementation of DessertContents composable, which contains an image and a text of dessert.

Implementing DessertDetailScreen

Here, we are going to see the implementation of DessertDetailScreen composable, which contains an image and the name of the dessert. The save button closes the DessertDetailScreen.

That’s all we need to do for shared element transition with Animated Visibility.


You can find the complete code of the above sample demo on GitHub.

Conclusion
Customising the Shared Element Transition in Jetpack Compose enhances screen transitions, making them smoother and more visually appealing. With AnimationSpec, you can control movement, like curving text paths, while Animated Visibility enables smooth appearance and disappearance of elements. These APIs allow for seamless transitions of text, images, and other UI elements, improving the user experience.

For more information, you can visit the official document for the Shared Element Transition API.




 we will discuss:

What CompositionLocal is

How to use CompositionLocal

When to use CompositionLocal

Creating custom CompositionLocals

How providers work in CompositionLocal

We'll also illustrate these concepts with real code examples.

What is CompositionLocal?
In traditional Android UI development, you might use context or dependency injection to share data across components. In Jetpack Compose, CompositionLocal provides a way to implicitly pass data down the UI tree. This data can include theme settings, configurations, or any state that should be shared among multiple composables.

CompositionLocal is especially useful when you have values that many composables depend on but that don’t change frequently. Instead of explicitly passing these values as parameters to every composable, you can define a CompositionLocal that “remembers” these values and makes them available throughout the UI hierarchy.

How to Use CompositionLocal
Using CompositionLocal involves two main steps:

Defining the CompositionLocal:
You define a CompositionLocal object with a default value. This can be done using the compositionLocalOf or staticCompositionLocalOf functions. The static version is optimized for values that do not change often.

Providing a Value:
You use the CompositionLocalProvider composable to override the default value with a specific one in a given part of the UI hierarchy.

Consuming the Value:
Within any composable that is a descendant of the provider, you can access the value via the current property of your CompositionLocal.

Basic Example
Below is a simple example that defines a CompositionLocal for a theme color and then consumes it:

import androidx.compose.runtime.Composable
import androidx.compose.runtime.CompositionLocalProvider
import androidx.compose.runtime.compositionLocalOf
import androidx.compose.material.Text
import androidx.compose.ui.graphics.Color

// 1. Define a CompositionLocal with a default color
val LocalThemeColor = compositionLocalOf { Color.Black }

@Composable
fun AppContent() {
    // 2. Provide a custom theme color
    CompositionLocalProvider(LocalThemeColor provides Color.Blue) {
        ThemedText()
    }
}

@Composable
fun ThemedText() {
    // 3. Consume the CompositionLocal value
    val themeColor = LocalThemeColor.current
    Text("Hello, Compose!", color = themeColor)
}
In this example:

Definition: We create LocalThemeColor with a default of Color.Black.

Provision: In AppContent, we provide Color.Blue to the subtree.

Consumption: In ThemedText, we access the current color and apply it to the text.

When to Use CompositionLocal
CompositionLocal is best suited for scenarios where you have values that need to be accessible by many composables but aren’t part of the explicit parameters. Common use cases include:

Theming: Passing down colors, typography, or shapes.

Localization: Providing locale or formatting information.

Configuration: Supplying configuration data like layout directions or accessibility settings.

Dependency Injection: Sharing a repository, network client, or any other dependency across composables.

Because CompositionLocal provides implicit access, it can simplify your code and make it cleaner. However, it should be used judiciously to avoid “hidden” dependencies that make your code harder to understand and test.

Creating Custom CompositionLocals
While the Android framework and Jetpack Compose provide a number of built-in CompositionLocals (like those for theming), you can also create your own. The process is straightforward:

Define your custom CompositionLocal:
Use either compositionLocalOf or staticCompositionLocalOf to define your custom local value.

Wrap the relevant portion of your UI in a CompositionLocalProvider:
Use the provider to set the value for your custom CompositionLocal.

Consume the custom value in your composables.

Custom CompositionLocal Example
Let’s create a custom CompositionLocal that holds user configuration data:

import androidx.compose.runtime.Composable
import androidx.compose.runtime.CompositionLocalProvider
import androidx.compose.runtime.compositionLocalOf

data class UserSettings(val darkModeEnabled: Boolean, val fontSize: Int)


// 1. Define the CompositionLocal with a default UserSettings instance
val LocalUserSettings = compositionLocalOf { UserSettings(darkModeEnabled = false, fontSize = 14) }


@Composable
fun SettingsScreen() {
    // 2. Provide custom settings for the subtree
    val customSettings = UserSettings(darkModeEnabled = true, fontSize = 18)
    CompositionLocalProvider(LocalUserSettings provides customSettings) {
        SettingsText()
    }
}


@Composable
fun SettingsText() {
    // 3. Consume the CompositionLocal value
    val settings = LocalUserSettings.current
    val mode = if (settings.darkModeEnabled) "Dark Mode" else "Light Mode"
    Text("Mode: $mode, Font Size: ${settings.fontSize}")
}
In this code:

Definition: We define LocalUserSettings with a default configuration.

Provision: We supply a custom user setting inside SettingsScreen.

Consumption: SettingsText retrieves and displays the settings.

Advanced Example: Shared Transition and Animated Visibility Scopes
In more complex UI scenarios, you might want to share behavior or state across a navigation flow or animated transitions. Consider the following example that sets up two custom CompositionLocals—one for a SharedTransitionScope and another for an AnimatedVisibilityScope.

import androidx.compose.material.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.CompositionLocalProvider
import androidx.compose.runtime.compositionLocalOf

// Define the CompositionLocals with default values of null.
val LocalSharedTransitionScope = compositionLocalOf<SharedTransitionScope?> { null }

val LocalNavAnimatedVisibilityScope = compositionLocalOf<AnimatedVisibilityScope?> { null }


@Composable
fun TransitionProviderExample() {
    // Create instances of the scopes.
    val sharedTransitionScope = SharedTransitionScope()
    val animatedVisibilityScope = AnimatedVisibilityScope()
    
    // Provide the scope instances to the composition.
    CompositionLocalProvider(
        LocalSharedTransitionScope provides sharedTransitionScope,
        LocalNavAnimatedVisibilityScope provides animatedVisibilityScope
    ) {
        // Inside this block, the provided scopes can be consumed by child composables.
        ChildComposable()
    }
}

@Composable
fun ChildComposable() {
    // Retrieve the current scope instances from the CompositionLocals.
    val transitionScope = LocalSharedTransitionScope.current
    val visibilityScope = LocalNavAnimatedVisibilityScope.current

    // Use the scopes to perform actions or configure UI behavior.
    // Here we display simple text indicating whether the scopes are available.
    Text("SharedTransitionScope available: ${transitionScope != null}")
    Text("AnimatedVisibilityScope available: ${visibilityScope != null}")

    // Optionally, invoke functions on these scopes.
    transitionScope?.doTransition()
    visibilityScope?.animateVisibility()
}
How This Advanced Example Works
Scope Definitions:
SharedTransitionScope and AnimatedVisibilityScope, simulate shared functionality such as transitions and animations.

CompositionLocal Definitions:
We define two CompositionLocals with default values of null:

val LocalSharedTransitionScope = compositionLocalOf<SharedTransitionScope?> { null } val LocalNavAnimatedVisibilityScope = compositionLocalOf<AnimatedVisibilityScope?> { null }
Providing Values:
In the TransitionProviderExample composable, we instantiate both scopes and provide them to the composition using CompositionLocalProvider.

Consuming Values:
In ChildComposable, the provided scopes are accessed using the .current property. We then display text to indicate their availability and invoke their functions.

This pattern is very useful when you need to share behavior across a complex UI without cluttering your function parameters.

How Providers Work in CompositionLocal
The provider in CompositionLocal is implemented through the CompositionLocalProvider composable. It works by overriding the default value of a CompositionLocal for its child composables. This is analogous to how React’s Context providers work.

Key Points:
Scope: The value provided is only accessible to the composables that are within the provider’s scope. If a composable lies outside this scope, it will fall back to the default value.

Recomposition: When the value provided changes, only the composables that read the value will be recomposed, ensuring efficient updates.

Stacking Providers: You can nest multiple providers to override values at different levels in your UI tree.

Conclusion
CompositionLocal is an essential tool in Jetpack Compose for managing implicit state and configuration across your UI. By defining a CompositionLocal, providing a value with CompositionLocalProvider, and consuming it in your composables, you can create cleaner, more modular, and easier-to-manage UI code.



Try implementing this yourself, share your results, tag me, and let's spread the magic of Jetpack Compose together!

Happy coding! 🎉


requirements are for implementing WebP animations in Android kotlin jetpack compose
Here are the key requirements and considerations for implementing WebP animations in Android Kotlin with Jetpack Compose:
1. Minimal API level and WebP support
Android 4.2.1 (API level 17) or higher is required for full WebP support, including transparency and lossless compression.
For transparency or lossless compression, your minSdkVersion in your Android project should be at least 18. 
2. Choosing an image loading library
While Android supports WebP natively, for handling animated WebP files within Jetpack Compose, using an external image loading library is often necessary.
Recommended options include Coil and Glide.
Libraries like Landscapist offer integration with Coil, Glide, and Fresco, and also support WebP animations within Compose. 
3. Integrating the chosen library
Add the selected library's dependency to your build.gradle file (e.g., Coil).
Use the library's Composables to load and display the WebP animation (e.g., AsyncImage for Coil).
Ensure that the library specifically supports animated WebP, as not all image loading libraries handle them by default. 
4. Animation structure (if not using an animated WebP file directly)
If your WebP animation is composed of individual frames, you can create an AnimationDrawable and add each WebP image as a frame.
You can then pass this AnimationDrawable to the Compose Image composable using rememberDrawablePainter and start the animation manually. 
5. Performance optimization
Animated WebP generally offers better performance and smaller file sizes than animated GIFs.
Use lossy compression for animated WebP where acceptable to reduce file size further.
Optimize frame durations within your WebP animations for smoother playback. 
6. Additional considerations
Provide meaningful content descriptions for accessibility.
Explore advanced animation features in Compose for smoother transitions or complex effects (e.g., animateContentSize, AnimatedContent).
For advanced use cases or specific requirements, consider using low-level animation APIs in Compose or libraries like Lottie for pre-designed animations. 
AI responses may include mistakes. Learn more


Show me how to load animated WebP with Coil in Compose
Loading animated WebP images with Coil in Jetpack Compose
Coil is a powerful image loading library for Android, and it makes handling animated WebP files in Compose relatively straightforward. Here's a step-by-step guide: 
1. Add the Coil dependency
In your project's build.gradle (Module: app) file, add the Coil Compose dependency within the dependencies block: 
gradle
dependencies {
    // ... other dependencies
    implementation("io.coil-kt:coil-compose:2.7.0") // Or the latest version available
}
Use code with caution.

2. Use the AsyncImage composable
Once the dependency is added, you can use Coil's AsyncImage composable in your Compose UI to load and display the animated WebP file.
Example loading from a URL
kotlin
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import coil.compose.AsyncImage

@Composable
fun AnimatedWebPLoader(
    imageUrl: String // URL of your animated WebP
) {
    AsyncImage(
        model = imageUrl, // Your animated WebP image URL
        contentDescription = "Animated WebP Image", // Provide a meaningful description for accessibility
        modifier = Modifier.fillMaxWidth() // Adjust the modifier as needed
    )
}
Use code with caution.

Explanation
AsyncImage: This is Coil's primary composable for loading images asynchronously.
model: This argument specifies the image source. You can pass a URL (as in the example) or an ImageRequest object for more control.
contentDescription: It's crucial for accessibility to provide a descriptive text for the image. Screen readers use this description to inform users about the content of the image. You can use stringResource() for translatable descriptions.
modifier: You can apply any standard Compose modifiers to control the layout and appearance of the image. 
Handling local animated WebP files (drawables)
If your animated WebP file is stored locally as a drawable, you can load it using a similar approach with painterResource inside the ImageRequest model.
kotlin
import androidx.compose.foundation.Image
import androidx.compose.runtime.Composable
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.Modifier
import coil.compose.rememberAsyncImagePainter
import coil.request.ImageRequest
import androidx.compose.ui.platform.LocalContext


@Composable
fun LocalAnimatedWebPLoader(
    @DrawableRes drawableResId: Int // Resource ID of your animated WebP drawable
) {
    val context = LocalContext.current
    Image(
        painter = rememberAsyncImagePainter(
            ImageRequest.Builder(context)
                .data(drawableResId) // The drawable resource ID
                .crossfade(true) // Optional: add a crossfade animation
                .build()
        ),
        contentDescription = "Animated WebP from drawable",
        modifier = Modifier.fillMaxWidth()
    )
}
Use code with caution.

Controlling animation playback (e.g., play once)
If you need to control the animation (e.g., play it only once), you can use the repeatCount parameter within the ImageRequest builder. 
kotlin
import androidx.compose.foundation.Image
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import coil.compose.rememberAsyncImagePainter
import coil.request.ImageRequest
import androidx.compose.ui.platform.LocalContext

@Composable
fun PlayWebPOnce(
    imageUrl: String
) {
    val context = LocalContext.current
    Image(
        painter = rememberAsyncImagePainter(
            ImageRequest.Builder(context)
                .data(imageUrl)
                .repeatCount(0) // Play the animation only once
                .build()
        ),
        contentDescription = "Animated WebP played once",
        modifier = Modifier.fillMaxWidth()
    )
}
Use code with caution.

By following these examples, you can effectively load and display animated WebP images within your Android Jetpack Compose applications using the Coil library. 
AI responses may include mistakes. Learn more


Elaborate on how to use ImageRequest for advanced WebP loading with Coil
When you need more fine-grained control over how Coil loads and displays an animated WebP, you can use the ImageRequest builder. This allows you to specify various options beyond simply providing a URL. 
Here's an elaboration on how to use ImageRequest for advanced WebP loading with Coil in Jetpack Compose:
1. Creating the ImageRequest
The ImageRequest is created using a builder pattern. You initiate the builder with a Context and then chain methods to customize the request. 
kotlin
import coil.request.ImageRequest
import coil.transform.CircleCropTransformation // Example transformation
import androidx.compose.ui.platform.LocalContext 

// In your Composable:
val context = LocalContext.current
val imageRequest = ImageRequest.Builder(context)
    .data("your_animated_webp_url_or_drawable_resource") 
    // Add your desired options here
    .build()
Use code with caution.

2. Key ImageRequest options for WebP animation
Here are some important ImageRequest options to consider when working with animated WebP:
data(Any): Specifies the image source. This can be a URL string, a drawable resource ID, a File object, a Uri, or even a Bitmap.
crossfade(Boolean): Enables a crossfade animation when the image loads. This can be true or false.
placeholder(DrawableResId) / placeholder(Drawable): Sets a drawable to display while the image is loading.
error(DrawableResId) / error(Drawable): Sets a drawable to display if the image loading fails.
fallback(DrawableResId) / fallback(Drawable): Sets a drawable to display if the data is null or invalid.
size(Size): Requests the image to be loaded with a specific size, potentially preventing loading a larger image than necessary.
scale(Scale): Defines how the image should be scaled to fit the target size (e.g., Scale.FIT, Scale.FILL).
transformations(vararg Transformation): Applies transformations to the image, like CircleCropTransformation, RoundedCornersTransformation, etc.
memoryCachePolicy(CachePolicy): Controls how the image is stored in the memory cache.
diskCachePolicy(CachePolicy): Controls how the image is stored in the disk cache.
repeatCount(Int): For animated images like WebP, this specifies the number of times the animation should loop. Setting it to 0 means it will play once.
listener(ImageRequest.Listener): Provides callbacks for various loading states (onStart, onCancel, onError, onSuccess). 
3. Advanced scenarios and customizations
a. Playing WebP animation only once
To play an animated WebP only once, set repeatCount(0) in your ImageRequest: 
kotlin
val singlePlayRequest = ImageRequest.Builder(context)
    .data("your_animated_webp_url")
    .repeatCount(0) 
    .build()
AsyncImage(model = singlePlayRequest, contentDescription = "Animated WebP (Plays Once)")
Use code with caution.

b. Custom transformations for animated WebP
While simple transformations like CircleCropTransformation can be applied directly to the ImageRequest, Coil's documentation on GIFs mentions using AnimatedTransformation for more complex transformations on each frame of an animated GIF. This principle extends to animated WebP as well. You'd create a custom AnimatedTransformation and pass it to the transformations method of your ImageRequest. 
c. Handling different loading states with SubcomposeAsyncImage
For more granular control over the UI during different loading states (loading, success, error), use SubcomposeAsyncImage. This allows you to provide separate composables for each state. 
kotlin
import coil.compose.SubcomposeAsyncImage
import androidx.compose.material.CircularProgressIndicator // Example loading indicator

SubcomposeAsyncImage(
    model = imageRequest, // Your ImageRequest with WebP animation
    loading = { CircularProgressIndicator() }, 
    error = { /* Custom Error composable */ },
    contentDescription = "Animated WebP"
)
Use code with caution.

4. Considerations for older Android versions
For animated WebP support on API levels below 28, you may need to use the AnimatedImageDecoder if available in your Coil version, as Android's ImageDecoder is available from API 28 onwards.
Always check the Coil documentation for any specific requirements or recommendations related to your target API levels and image formats. 
By leveraging the various options available in the ImageRequest builder, you can achieve sophisticated and customized loading and display of animated WebP files with Coil in your Jetpack Compose applications. 
AI responses may include mistakes. Learn more


Show me how to implement a custom AnimatedTransformation for WebP animation with Coil
Implementing a custom AnimatedTransformation for WebP animations with Coil
Coil's AnimatedTransformation allows you to apply transformations to each frame of an animated image like WebP. This gives you powerful control over the visual style of your animations. Here's a breakdown of how to implement one: 
1. Understanding AnimatedTransformation
AnimatedTransformation is an interface provided by Coil's GIF extension library (which also supports animated WebP).
It defines a transform method that takes a Bitmap (the current frame of the animation) and returns a transformed Bitmap.
Crucially, this transform method is called for each frame of the animated WebP as it's decoded and prepared for display. 
2. Setting up the dependencies
Ensure you have the necessary Coil dependencies in your build.gradle (Module: app) file: 
gradle
dependencies {
    // ... other dependencies
    implementation("io.coil-kt:coil-compose:2.7.0") // Or the latest version
    implementation("io.coil-kt:coil-gif:2.7.0") // Essential for animated WebP/GIF support
}
Use code with caution.

3. Creating your custom AnimatedTransformation
Let's create a custom transformation that adds a vignette effect to each frame of the animated WebP. 
kotlin
import android.graphics.Bitmap
import android.graphics.Canvas
import android.graphics.ColorFilter
import android.graphics.LightingColorFilter
import coil.transform.AnimatedTransformation
import coil.size.Size

class VignetteTransformation : AnimatedTransformation {
    override val cacheKey: String = VignetteTransformation::class.java.name

    override suspend fun transform(
        input: Bitmap, 
        size: Size, 
        padding: Int
    ): Bitmap {
        val output = Bitmap.createBitmap(input.width, input.height, input.config)
        val canvas = Canvas(output)

        // Apply a subtle darkening effect to the edges (vignette)
        val filter: ColorFilter = LightingColorFilter(0xFF7F7F7F.toInt(), 0x00000000) 
        canvas.drawBitmap(input, 0f, 0f, null) // Draw the original frame
        canvas.drawRect(0f, 0f, input.width.toFloat(), input.height.toFloat(), android.graphics.Paint().apply {
            colorFilter = filter
            alpha = 100 // Adjust the alpha for the strength of the vignette
        })
        
        return output
    }

    override fun equals(other: Any?): Boolean {
        return other is VignetteTransformation
    }

    override fun hashCode(): Int {
        return VignetteTransformation::class.java.hashCode()
    }
}
Use code with caution.

4. Applying the custom AnimatedTransformation
Now, you can apply your VignetteTransformation to your ImageRequest: 
kotlin
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import coil.compose.AsyncImage
import coil.request.ImageRequest

@Composable
fun WebPWithVignette(
    imageUrl: String 
) {
    val context = LocalContext.current
    val imageRequest = ImageRequest.Builder(context)
        .data(imageUrl) 
        .transformations(VignetteTransformation()) // Apply your custom transformation
        .build()

    AsyncImage(
        model = imageRequest,
        contentDescription = "Animated WebP with Vignette",
        modifier = Modifier.fillMaxWidth()
    )
}
Use code with caution.

Explanation
VignetteTransformation: This custom class implements the AnimatedTransformation interface.
cacheKey: It's crucial to provide a unique cacheKey for your transformation. This helps Coil cache the transformed images efficiently.
transform method:
This is where the actual transformation logic resides.
It takes the input Bitmap (the current frame), the size of the target (though we're not using it directly in this example), and padding.
We create a new output Bitmap of the same size.
We create a Canvas to draw on the output Bitmap.
Then, we draw the input Bitmap (the original frame) onto the canvas.
To create the vignette, we apply a LightingColorFilter with a specific color and alpha value, and draw a rectangle over the frame.
Finally, we return the transformed output Bitmap. 
Important considerations
Performance: Custom transformations can have a performance impact, especially on complex animations or low-end devices. Optimize your transformation logic as much as possible.
Memory Usage: Creating new Bitmaps for each frame can increase memory usage. Be mindful of this and potentially re-use Bitmaps if possible, or consider more efficient transformation techniques for your specific use case.
Complexity: If your transformation is very complex, you might need to explore other approaches like using OpenGL or Renderscript for better performance.
Coil Version: Always check the Coil documentation and ensure compatibility with your Coil version when implementing custom transformations. 
By following these steps, you can create and apply your own custom transformations to WebP animations, opening up a world of creative possibilities for your Android apps!
AI responses may include mistakes. Learn more



gradle 9 
Upgrade instructions
Switch your build to use Gradle 9.0.0 by updating the wrapper in your project:

./gradlew wrapper --gradle-version=9.0.0 && ./gradlew wrapper
See the Gradle 9.0.0 upgrade guide to learn about deprecations, breaking changes, and other considerations when upgrading to Gradle 9.0.0.

For Java, Groovy, Kotlin, and Android compatibility, see the full compatibility notes.

New features and usability improvements

Configuration Cache improvements
Gradle's Configuration Cache improves build performance by caching and reusing the result of the configuration phase.

Configuration Cache as the preferred execution mode
The Configuration Cache is the preferred mode of execution. While not yet required, Gradle encourages adoption by prompting users and gradually phasing out incompatible APIs to prepare for a future where it becomes the only supported mode.

Prompt to enable Configuration Cache
If your build has no known Configuration Cache incompatibilities but doesn't yet have the Configuration Cache enabled, Gradle will suggest enabling it at the end of the build:

Configuration Cache prompt to enable

Some issues can only be detected when the Configuration Cache is active, so additional refinements may still be needed to fully adopt it.

If you're not ready to invest time in this yet, you can suppress the suggestion by explicitly disabling the feature in your gradle.properties file:

org.gradle.configuration-cache=false
Graceful fallback from Configuration Cache mode
Gradle falls back to non-Configuration Cache mode automatically when encountering unsupported features, instead of failing the build.

This includes:

Core plugins with limited support (such as Maven Publish and Ivy Publish)
Unsupported or incompatible IDE plugins (such as Eclipse and IDEA)
Features not yet supported (such as Source Dependencies)
After running a build, the reason for the fallback can be found in the Configuration Cache report.

Other notable Configuration Cache updates
Additional updates for the Configuration Cache include:

Tasks marked as incompatible prevent cache hits in warning mode, ensuring correctness. Warning mode should only be used during migration or troubleshooting. Marking tasks as incompatible remains a recommended strategy for gradual adoption.
Task execution will abort immediately when a Configuration Cache problem is encountered, avoiding undefined behavior and ensuring affected tasks are neither marked up-to-date nor cached.
The Configuration Cache report includes more detailed errors, such as serialization issues, unsafe concurrent access, and Groovy DSL closures capturing script state.

Gradle requires Java Virtual Machine (JVM) version 17 or higher to run
Gradle requires a Java Virtual Machine (JVM) version 17 or higher to start the Gradle daemon.

If you need to build with older JVM versions, you can specify a separate JDK toolchain in the build definition by using toolchains.
Gradle still supports compiling, testing and running other JVM-based tools with Java 8 and higher.

See the Compatibility Matrix for more information.


Update to Kotlin 2
Gradle embeds the latest stable release of Kotlin 2.2.x runtime and uses Kotlin language version 2.2. This marks a shift from Gradle 8.x, which embedded Kotlin 2.0 starting in 8.11 but continued to use Kotlin language version 1.8 for compatibility.

For a comprehensive overview of what’s new, see the Kotlin 2.2.0, Kotlin 2.1.0 and Kotlin 2.0.0 release notes.

Gradle uses Kotlin for build logic, which includes:

Build scripts written in the Kotlin DSL (.gradle.kts files)
Plugins
As a result, some behavior has changed, most notably the new K2 compiler and nullability annotations on APIs. If you're upgrading, review the Gradle 9.0.0 upgrade guide for migration details.


Update to Groovy 4
Gradle embeds the latest stable release of Groovy 4.0, a major upgrade from the Groovy 3.0 version used in Gradle 7 and 8.

This update introduces a range of new features and improvements to the Groovy language. For a comprehensive overview of what’s new, see the Groovy 4.0 release notes for full details.

Gradle uses Groovy for build logic, which includes: Build scripts written in the Groovy DSL (.gradle files) Ant integration Plugins

Some behavior has changed between Groovy 3.0 and 4.0. If you're upgrading, review the Gradle 9.0.0 upgrade guide for migration details.


Semantic Versioning for Gradle releases
Starting with Gradle 9, all Gradle releases follow the Semantic Versioning (SemVer) specification.

Version numbers are expressed as MAJOR.MINOR.PATCH, whereas previous minor releases omitted the patch segment (e.g., 8.5 instead of 8.5.0).

This change only applies to new releases and does not retroactively affect older versions or backports. Additionally, internal code and features marked with @Incubating are not considered part of the public API and may change in minor releases.


Build authoring improvements
Gradle provides rich APIs for plugin authors and build engineers to develop custom build logic.


Kotlin build script compilation avoidance
Gradle speeds up feedback loops when editing build logic by avoiding unnecessary recompilation of Kotlin DSL (.kts) build scripts. This reduces build times and improves developer productivity.

The improvement comes from significantly better detection of ABI (Application Binary Interface) changes, made possible by using Kotlin’s built-in ABI fingerprinting instead of Gradle’s previous internal mechanism. This brings major performance benefits, especially in builds that use inline functions, which were not handled efficiently before.

For example, in the Gradle build itself, non-ABI changes to build logic result in up to a 60% reduction in configuration time by avoiding unnecessary script recompilation.

Reduction in unnecessary script recompilation


Gradle API uses JSpecify Nullability annotations
Since Gradle 5.0 we've been using annotations from JSR-305 to make the nullness of type usages explicit for the Gradle API. Starting with Gradle 9, the Gradle API is annotated using JSpecify instead.

Kotlin 2.1, when combined with JSpecify annotations in the Gradle API, introduces stricter nullability handling. For more details and potential breakages, see the dedicated upgrading guide section.


Support for major and minor version specification in Gradle Wrapper
Gradle supports specifying only a major or minor version when configuring the wrapper.

For example, the following resolves to the latest 9.x.y release:

./gradlew wrapper --gradle-version=9
While the following resolves to the latest 9.1.x release:

./gradlew wrapper --gradle-version=9.1
This feature requires Gradle 9.0.0 or later. Earlier versions don’t follow full semantic versioning and may misinterpret partial versions (e.g., 8.12 might refer to 8.12 (because it's an exact version) and 8.12.1 (semantically the latest version for 8.12).

Gradle’s version information endpoint has been extended to support this behavior. For instance, https://services.gradle.org/versions/9 lists all versions of Gradle with major version 9.

Archive tasks produce reproducible archives by default
Archive tasks such as Jar, Ear, War, Zip, Tar, and AbstractArchiveTask produce reproducible archives by default. This means that generated archives have reproducible file order and preconfigured file timestamps and permissions. As a result archives generated from the same inputs will be identical byte-for-byte.

This change may affect builds that rely on non-deterministic archive characteristics like file order, file system timestamps, or file system permissions, or file executable bit.

For more information, see the upgrading guide section.

Detached configurations can resolve dependencies on their own project
Detached configurations are able to resolve dependencies that reference their own project.

To do this, Gradle introduces a new subtype of ComponentIdentifier called RootComponentIdentifier, which represents the root node of a resolved dependency graph.

When a configuration is resolved, it is first transformed into a synthetic variant. This variant is owned by a synthetic root component, which is identified using RootComponentIdentifier. The root component itself exists only to own the root variant.

Dependency graphs resolved from detached configurations and buildscript configurations will have a component identified by a RootComponentIdentifier at the root of their graph. This lets Gradle differentiate between a detached configuration and the project it lives in.

Resolved project configurations will continue to have their root component live within the project's component and identified by a ProjectComponentIdentifier. In future Gradle versions, all configurations, including those declared inside projects (non-detached), will be owned by a synthetic root component identified by a RootComponentIdentifier.

JAVA_HOME environment variable used for toolchain auto-detection
Gradle's toolchain support allows provisioning and selection of specific JDK versions for building projects—compiling code, running tests, and even running Gradle itself.

This release adds support for using the JAVA_HOME environment variable as a source for toolchain auto-detection. This change improves consistency between toolchains detected from the command line and those detected by IDEs, which previously did not consider JAVA_HOME.


Documentation improvements
Gradle Best Practices
In partnership with JetBrains and Google, we've launched a new Gradle Best Practices guide to help you avoid common pitfalls and write more maintainable, performant builds. These recommendations consolidate community knowledge and Gradle team insights into a single, growing resource. The current version covers best practices in dependency declarations, build structure, task authoring, and more.

For more information, check out the Gradle Best Practices blog post.

Promoted features
Promoted features are features that were incubating in previous versions of Gradle but are now supported and subject to backward compatibility. See the User Manual section on the "Feature Lifecycle" for more information.

The following are the features that have been promoted in this Gradle release.

Promoted features in the Kotlin DSL
The following operator functions in DependencyHandlerScope are considered stable:

NamedDomainObjectProvider<Configuration>.invoke(dependencyNotation: Any): Dependency?
NamedDomainObjectProvider<Configuration>.invoke(dependencyNotation: String, dependencyConfiguration: ExternalModuleDependency.() -> Unit): ExternalModuleDependency
NamedDomainObjectProvider<Configuration>.invoke(group: String, name: String, version: String?, configuration: String?, classifier: String?, ext: String?): ExternalModuleDependency
NamedDomainObjectProvider<Configuration>.invoke(group: String, name: String, version: String?, configuration: String?, classifier: String?, ext: String?, dependencyConfiguration: ExternalModuleDependency.() -> Unit): ExternalModuleDependency
<T : Any> Configuration.invoke(dependency: Provider<T>, dependencyConfiguration: ExternalModuleDependency.() -> Unit)
<T : Any> Configuration.invoke(dependency: ProviderConvertible<T>, dependencyConfiguration: ExternalModuleDependency.() -> Unit)
<T : Any> NamedDomainObjectProvider<Configuration>.invoke(dependency: Provider<T>)
<T : Any> NamedDomainObjectProvider<Configuration>.invoke(dependency: ProviderConvertible<T>)
<T : Any> NamedDomainObjectProvider<Configuration>.invoke(dependency: Provider<T>, dependencyConfiguration: ExternalModuleDependency.() -> Unit)
<T : Any> NamedDomainObjectProvider<Configuration>.invoke(dependency: ProviderConvertible<T>, dependencyConfiguration: ExternalModuleDependency.() -> Unit)
<T : Any> String.invoke(dependency: Provider<T>, dependencyConfiguration: ExternalModuleDependency.() -> Unit)
<T : Any> String.invoke(dependency: ProviderConvertible<T>, dependencyConfiguration: ExternalModuleDependency.() -> Unit)
<T : ModuleDependency> NamedDomainObjectProvider<Configuration>.invoke(dependency: T, dependencyConfiguration: T.() -> Unit): T
The following operator functions in DependencyConstraintHandlerScope are considered stable:

NamedDomainObjectProvider<Configuration>.invoke(dependencyConstraintNotation: Any): DependencyConstraint
NamedDomainObjectProvider<Configuration>.invoke(dependencyConstraintNotation: String, configuration: DependencyConstraint.() -> Unit): DependencyConstraint
The following top-level functions in DependencyHandlerExtensions are considered stable:

DependencyHandler.create(dependencyNotation: String, dependencyConfiguration: ExternalModuleDependency.() -> Unit): ExternalModuleDependency
The following top-level functions in KotlinDependencyExtensions are considered stable:

PluginDependenciesSpec.embeddedKotlin(module: String): PluginDependencySpec
The following functions are considered stable:

GroovyBuilderScope.hasProperty(name: String): Boolean
Fixed issues
148 issues have been fixed in Gradle 9.0.0.

[#33930] - eddsa CVE CWE-347
[#33929] - jgit CVE-2025-4949
[#33861] - Exec.args should be configurable as a property with Kotlin
[#33854] - CC problem for execution-time Groovy script object access
[#33848] - Remove MavenDependency
[#33720] - Update generated doc links to match new structure
[#33713] - Flow action provider may cause "Resolution of the configuration was attempted without an exclusive lock." error
[#33692] - Old version of javaparser dependency prohibit parsing Java17
[#33664] - `:kotlinDslAccessorsReport` prints incorrect sources for accessors to members of inaccessible types
[#33661] - Interface `BuildExecutionContext.java` appears to be unused
[#33658] - Deprecate ValueState.beforeMutate() in 9.x
[#33638] - XmlTransformerTest in `./gradlew :core:test` fails on local machine due to locale-dependent exception messages
[#33634] - Gradle Module Metadata spec: clarify valid attribute value types
[#33617] - Broken links in sample_cross_project_output_sharing.html documentation
[#33603] - `kotlinDslAccessorsReport` is not compatible with Configuration Cache
[#33539] - ConcurrentModificationException in Groovy 4 MetaClassImpl
[#33528] - Inner classes that reference external plugin classes cannot be used in precompiled buildscripts
[#33526] - Promote Configuration Cache for builds that do not explicitly enable or disable it
[#33516] - PluginSpecBuilders accessors for precompiled script plugins outputs are too unstable
[#33490] - withoutArtifactSelector does not actually remove the artifact selector when substituting a module dependency for a project dependency
[#33387] - Generated accessors should expose plugin types deprecation
[#33386] - Generated accessors should also suppress deprecation errors
[#33382] - Remove convention mapping in EarPlugin
[#33355] - Remove conventions from codebase
[#33349] - Add back import to javax.inject.Inject in documentation
[#33348] - 'Executing Artifact Transforms' example has task with discouraged practice
[#33306] - Documentation links to the archived gradle-credentials-plugin
[#33301] - Confusing example in "Best Practices for Dependencies"
[#33296] - mention dirPermissions/filePermissions in reproducible build section
[#33240] - The @RELEASE_NAME@ placeholder in the signed artifact ASC file is present
[#33225] - Make DefaultSettingsLoader fail on missing directory
[#33215] - Non-abstract managed properties can lose their owner under Groovy 4
[#33168] - Remove deprecated archivePath property
[#33161] - `invokedynamic` is not considered for incremental compilation class dependencies
[#33147] - Rework Groovy tests to ensure earlier Groovy version compilation is still supported
[#33093] - Remove deprecated command-line option to use custom build and settings scripts
[#33075] - When snippets can't run due to configuration issues, say something
[#33057] - Remove deprecated CollectionUtils
[#33018] - Remove deprecated ApplicationConvention
[#33017] - Remove deprecated EarConvention
[#33012] - Method naming typo "emphatize"
[#33000] - Remove unused groovy dependencies from distribution
[#32995] - Remove deprecated JavaPluginConvention
[#32992] - DirectoryProperty and RegularFileProperty resolve relative paths incorrectly when loading from CC
[#32990] - Remove deprecated ReportingPluginConvention
[#32972] - Flaky ToolingApiClientCurrentJdkCompatibilityTest
[#32969] - Toolchains ignore LongRunningOperation.setEnvironmentVariables
[#32958] - AttributeDisambiguationRule registration example appears incorrect
[#32938] - Remove deprecated elements in BasePlugin
[#32889] - Update Tooling API compatibility matrix
[#32858] - Broken link in 'Modifying Dependency Metadata'
[#32857] - Gradle 9.0 regression on handling of properties in extensions
[#32693] - Remove implicit building of artifacts for assemble
[#32650] - All Configurations should have locked roles
[#32564] - Configuration cache error: Class 'org.gradle.internal.classpath.Instrumented$$Lambda$2709/0x00000098020e55e0' cannot be encoded
[#32560] - CheckStyle configuration for JDK 8 example
[#32542] - CC problems reported at execution time can be hidden by build cache on subsequent runs
[#32483] - Rework Groovy 4 is-property deprecation carefully
[#32464] - Different fingerprints in the compile classpath for the same dependency.
[#32451] - Gradle saves configuration cache for incompatible tasks when problems are turned to warnings
[#32444] - Gradle fails to discover jdk from inside IntelliJ
[#32370] - Upgrade workers and tooling-api modules to Java 8
[#32212] - Upgrade to Groovy 4
[#32019] - Kotlin RequiresOptIn annotation is not forwarding into generated accessor
[#31963] - Spurious warning "Mutating the dependencies of configuration"
[#31916] - Repeated VariantSelectionByAttributesException messages during Scala compilation
[#31840] - Remove load-after-store flag
[#31484] - JavaExec allJvmArgs property is missing user added arguments
[#31452] - Add SPDX metadata to the wrapper MANIFEST.MF
[#31448] - Groovy property setter interceptors fallback doesn't do type coercion
[#31329] - ExecResult `assertNormalExitValue()` and `rethrowFailure()` throw internal ExecException
[#31089] - Deprecate and remove UncheckedIOException
[#31088] - Apply graceful degradation to the CC-incompatible tasks of software model
[#31027] - Prepare the Gradle 9.0 branch
[#30871] - Reproducible archives enabled by default
[#30805] - Groovy interception with Groovy 4.x causes stackoverflow for implicit receivers
[#30654] - Double memory usage when the configuration cache is enabled
[#30620] - Upgrade default PMD version to 7
[#30530] - The Gradle Play Plugin needs a new release that will work with Gradle 9
[#30516] - Drop support for obsolete shadow plugin in 9.0
[#30373] - Make JUnitOptions and JUnitPlatformOptions abstract with Gradle 9
[#30320] - Add RootComponentIdentifier for root components
[#30198] - Failure during classpath dependency resolution
[#30102] - Prepare for CC as the preferred mode in Gradle 9
[#29695] - Remove Wrapper.setWrapperVersionsResources from public API
[#29241] - Add public API to configure ConfigurationVariant description
[#28727] - Verify classloader pieces when loading from configuration cache
[#28435] - Make all injector-getters abstract in public types
[#28014] - The `CompilePrecompiledScriptPluginPlugins` task should be replaced with a custom `KotlinCompile` task
[#27867] - Indicate safe varargs properly
[#27390] - Capture scripts classpath as Configuration Cache fingerprint
[#26942] - Configuration cache error with Java11 collections
[#26534] - ☔ Use Kotlin K2 compiler for Gradle Kotlin DSL script compilation
[#26532] - Try out new Kotlin ABI fingerprint from the Kotlin distribution
[#26531] - ☔ Kotlin DSL script compilation avoidance
[#26348] - Implement the slf4j 2 api on the builtin slf4j logger
[#25184] - Update kotlinx-metadata-jvm to 0.6.0
[#24861] - Switch Gradle to the new File Permissions API
[#24767] - Migrate to JSpecify annotations
[#24678] - Print actionable error message when junit dependencies are not available
[#24352] - Kotlin DSL script compilation avoidance ignores `internal` visibility changes on types
[#24040] - Explicit repository credentials break with configuration caching
[#23932] - Avoid early realization of compile tasks registered on source set output.classesDirs
[#23617] - RelativePath#getParent() return type should be marked as @Nullable
[#23369] - allow label "milestone" for wrapper --gradle-version
[#23268] - Missing console output when TestNG fails to initialize test classes
[#22907] - Nag for deprecation of StartParameterInternal.isConfigurationCache()
[#22882] - Proposal: Don't omit the `.0` from releases. Always include the patch version, even when it is zero.
[#22416] - Let Kotlin DSL script compilation use a faster JAR file-system
[#22383] - Remove deprecated UsageContext#getUsage
[#22090] - Verify that asciidoctor works with resolving configurations outside of project contexts error
[#22056] - Remove core conventions
[#21659] - Remove @Deprecated AbstractCompile.setDestinationDir
[#21533] - Remove @Deprecated TestReport.setDestination(File) method
[#21284] - Use Kotlin Language 2 and K2 Kotlin compiler for the Gradle Kotlin DSL
[#19318] - Docs improvement of "Simple sharing of artifacts between projects" section
[#19057] - Add "idiomatic builds" documentation page with the current best practices
[#17634] - An attempt to use finalizedBy during task execution is not notified when loading from the configuration cache
[#17533] - DirectoryProperty#file(Provider) loses task dependency
[#17309] - Support Kotlin's inline functions with build script compilation avoidance
[#16791] - Shouldn't JavaExec default to using the project's toolchain if any?
[#15530] - Report non `BuildService` listeners of `BuildEventsListenerRegistry.onTaskCompletion` as problems
[#15023] - Remove software model related help tasks
[#9591] - Cannot resolve a dependency on the root project in a detached configuration
[#6875] - Don't auto-attach all output artifacts for a project to the assemble task
[#6391] - The Gradle API bytecode should contain parameter names
[#34473] - 404 doc link when Gradle fails with 'Resolution of the configuration attempted without an exclusive lock'
[#34293] - Confusing passage in ConfigurationCache#RunningExternalProcesses
[#34168] - Gradle 9 upgrade guide does not include changes in the Groovy util packages
[#26363] - Document which `Provider`s are resolved at store time when configuration cache is used
[#34194] - "Verifying dependencies" page instructs user to overwrite entire keychain
[#34167] - Configuration Cache promo message is potentially shown for some incompatible builds
[#34163] - Misleading configuration cache summary line when displaying the report link without any problems
[#34132] - gradle-9-rc-1 caused stack overflow when adjusting Test task classpath
[#34064] - Eclipse's resolution of the configuration was attempted without an exclusive lock
[#34058] - Calling afterEvaluate in configurations.all fails when enabling source or javadoc
[#34038] - ConfigurableFileCollection.from and Project.files parameters are incorrectly marked non-null
[#34015] - Odd failures regarding custom project locations (9.0.0-rc1)
[#34004] - References to GitHub Wrapper Validation action out of date (404)
[#33950] - Failed to load JUnit Platform in 9.0.0-rc-1
[#33924] - Missing dependency even if all paths do not exclude it
[#27643] - 'org.gradle.parallel=true' causes false deprecation messages in a multi-project build
[#27447] - Tutorials should cover multiple programming languages
[#34252] - Builds with flaky tests now fail with cryptic "worker failures" when using Develocity
[#34190] - GradleProject model is not parallel-safe
[#34423] - 9.0.0-rc-3 release notes upgrade guide link points to Gradle 8.x upgrade guide
[#34372] - 9.0.0-rc-2: `DefaultTask.group` and `DefaultTask.descriptions` are not nullable
[#34349] - Gradle 9 (undocumented ?) change: compileJava output automatically updates sourceset destination dir
Known issues
Known issues are problems that were discovered post-release that are directly related to changes made in this release.

