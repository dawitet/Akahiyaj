package com.dawitf.akahidegn.viewmodel

import android.location.Location
import android.util.Log
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.dawitf.akahidegn.domain.model.Group
import com.dawitf.akahidegn.domain.model.GroupReader
import com.dawitf.akahidegn.data.PreferenceRepository
import com.dawitf.akahidegn.data.local.model.UserProfile
import com.dawitf.akahidegn.data.remote.service.LocationService
import com.dawitf.akahidegn.data.repository.UserProfileRepository
import com.google.firebase.database.DataSnapshot
import com.google.firebase.database.DatabaseReference
import dagger.hilt.android.lifecycle.HiltViewModel
import javax.inject.Inject
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.debounce
import kotlinx.coroutines.flow.distinctUntilChanged
import kotlinx.coroutines.flow.filter
import kotlinx.coroutines.launch
import kotlinx.coroutines.tasks.await
import kotlinx.coroutines.withContext

@HiltViewModel
class MainViewModel @Inject constructor(
    private val preferenceRepository: PreferenceRepository,
    private val userProfileRepository: UserProfileRepository,
    private val locationService: LocationService,
) : ViewModel() {

    private val _groups = MutableStateFlow<List<Group>>(emptyList())
    val groups: StateFlow<List<Group>> = _groups.asStateFlow()
    
    private val _isLoadingGroups = MutableStateFlow(false)
    val isLoadingGroups: StateFlow<Boolean> = _isLoadingGroups.asStateFlow()

    private val _searchQuery = MutableStateFlow("")
    val searchQuery: StateFlow<String> = _searchQuery.asStateFlow()

    private val _recentSearches = MutableStateFlow<List<String>>(emptyList())
    val recentSearches: StateFlow<List<String>> = _recentSearches.asStateFlow()

    private val _currentLocation = MutableStateFlow<Location?>(null)
    val currentLocation: StateFlow<Location?> = _currentLocation.asStateFlow()

    private val _selectedGroup = MutableStateFlow<Group?>(null)
    val selectedGroup: StateFlow<Group?> = _selectedGroup.asStateFlow()

    // Firebase references
    private lateinit var activeGroupsRef: DatabaseReference
    
    // Current search parameters
    // Increased radius for testing - normally 500 meters but using worldwide for debugging
    private val searchRadiusMeters = 25000000.0 // 25,000 km (effectively worldwide)
    private val maxRetries = 3
    private var currentFirebaseUserId: String? = null

    // Advanced caching and performance optimization
    private val groupsCache = mutableMapOf<String, Group>()
    private val recentSearchesCache = mutableListOf<String>()
    private val lastSearchTimestamp = mutableMapOf<String, Long>()
    private val CACHE_EXPIRY_MS = 5 * 60 * 1000L // 5 minutes
    
    // Memory optimization: Limit cache sizes
    private val MAX_GROUPS_CACHE_SIZE = 200
    private val MAX_RECENT_SEARCHES_SIZE = 20

    // Background dispatcher for heavy operations
    private val backgroundDispatcher = Dispatchers.IO
    private val computationDispatcher = Dispatchers.Default

    // Enhanced error handling and resilience
    private val _errorState = MutableStateFlow<String?>(null)
    val errorState: StateFlow<String?> = _errorState.asStateFlow()
    
    private var retryCount = 0
    private val baseRetryDelayMs = 1000L
    
    init {
        setupSearchQueryDebouncing()
        setupMemoryCleanup()
    }
    
    /**
     * Setup debounced search to prevent excessive Firebase calls
     */
    private fun setupSearchQueryDebouncing() {
        viewModelScope.launch {
            _searchQuery
                .debounce(300) // Wait 300ms after user stops typing
                .distinctUntilChanged() // Only proceed if the query actually changed
                .filter { currentFirebaseUserId != null } // Only search if authenticated
                .collect { query ->
                    Log.d("MainViewModel", "Debounced search triggered for: '$query'")
                    performGroupsSearch(query.trim().takeIf { it.isNotBlank() })
                }
        }
    }

    /**
     * Update search query - automatically triggers debounced search
     */
    fun updateSearchQuery(query: String) {
        _searchQuery.value = query
    }

    /**
     * Add a recent search with context for PreferenceManager
     */
    fun addRecentSearch(context: android.content.Context, search: String) {
        if (search.isBlank() || recentSearchesCache.contains(search)) return
        
        viewModelScope.launch(Dispatchers.IO) {
            // Use PreferenceManager directly here
            com.dawitf.akahidegn.PreferenceManager.addRecentSearch(context, search)
            
            // Update cache and UI
            recentSearchesCache.clear()
            recentSearchesCache.addAll(com.dawitf.akahidegn.PreferenceManager.getRecentSearches(context))
            
            withContext(Dispatchers.Main) {
                _recentSearches.value = recentSearchesCache.toList()
            }
        }
    }

    /**
     * Load recent searches from PreferenceManager
     */
    fun loadRecentSearches(context: android.content.Context) {
        viewModelScope.launch(Dispatchers.IO) {
            val searches = com.dawitf.akahidegn.PreferenceManager.getRecentSearches(context)
            recentSearchesCache.clear()
            recentSearchesCache.addAll(searches)
            
            withContext(Dispatchers.Main) {
                _recentSearches.value = searches
            }
        }
    }

    /**
     * Update current location and trigger nearby groups search
     */
    fun updateLocation(location: Location?) {
        _currentLocation.value = location
        // Trigger search when location is available
        if (location != null && currentFirebaseUserId != null) {
            viewModelScope.launch {
                performGroupsSearch(_searchQuery.value.trim().takeIf { it.isNotBlank() })
            }
        }
    }

    /**
     * Perform groups search with optimization and smart caching
     */
    private suspend fun performGroupsSearch(destinationFilter: String?) {
        Log.d("GROUP_REFRESH", "MainViewModel.performGroupsSearch(): Starting with filter: $destinationFilter")
        Log.i("Firebase", "MainViewModel.performGroupsSearch(): Starting with filter: $destinationFilter")
        
        if (_isLoadingGroups.value) {
            Log.d("GROUP_REFRESH", "MainViewModel.performGroupsSearch(): Search already in progress, skipping")
            Log.i("Firebase", "MainViewModel.performGroupsSearch(): Search already in progress, skipping")
            return
        }

        // Check if we have cached results for this search
        val userLoc = _currentLocation.value
        val cacheKey = "${destinationFilter ?: "all"}_${userLoc?.let { "${it.latitude}_${it.longitude}" } ?: "no_location"}"
        val lastSearchTime = lastSearchTimestamp[cacheKey] ?: 0
        val currentTime = System.currentTimeMillis()
        
        // FORCING REFRESH - Skip cache check
        Log.d("GROUP_REFRESH", "MainViewModel.performGroupsSearch(): FORCING FRESH DATA")
        Log.i("Firebase", "MainViewModel.performGroupsSearch(): FORCING FRESH DATA")

        _isLoadingGroups.value = true
        Log.d("GROUP_REFRESH", "MainViewModel.performGroupsSearch(): Performing groups search with filter: '$destinationFilter'")
        Log.i("Firebase", "MainViewModel.performGroupsSearch(): Performing groups search with filter: '$destinationFilter'")
        
        // Log the state of the database reference
        Log.d("GROUP_REFRESH", "Database reference path: ${activeGroupsRef.path}")
        Log.i("Firebase", "Database reference path: ${activeGroupsRef.path}")

        try {
            withContext(backgroundDispatcher) {
                // Try both timestamp and createdAt for maximal compatibility
                Log.d("GROUP_REFRESH", "MainViewModel.performGroupsSearch(): Using Firebase ref: $activeGroupsRef")
                Log.i("Firebase", "MainViewModel.performGroupsSearch(): Using Firebase ref: $activeGroupsRef")
                
                // Use simple get() without filters to see all data first
                activeGroupsRef.get().addOnSuccessListener { snapshot ->
                    val count = snapshot.childrenCount
                    Log.d("GROUP_REFRESH", "MainViewModel.performGroupsSearch(): Direct query found: $count groups")
                    Log.i("Firebase", "MainViewModel.performGroupsSearch(): Direct query found: $count groups")
                    
                    // Logging first few group keys for debugging
                    var counter = 0
                    snapshot.children.forEach { groupSnap ->
                        if (counter < 5) {  // Log only first 5 for brevity
                            Log.d("GROUP_REFRESH", "Group key: ${groupSnap.key}")
                            Log.i("Firebase", "Group key: ${groupSnap.key}")
                        }
                        counter++
                    }
                    
                    viewModelScope.launch(computationDispatcher) {
                        Log.d("GROUP_REFRESH", "MainViewModel.performGroupsSearch(): Processing data in computation thread")
                        Log.i("Firebase", "MainViewModel.performGroupsSearch(): Processing data in computation thread")
                        processGroupsData(snapshot, destinationFilter, cacheKey)
                    }
                }.addOnFailureListener { error ->
                    Log.e("GROUP_REFRESH", "MainViewModel.performGroupsSearch(): Search failed: ${error.message}", error)
                    Log.e("Firebase", "MainViewModel.performGroupsSearch(): Search failed: ${error.message}", error)
                    _isLoadingGroups.value = false
                }
            }
        } catch (e: Exception) {
            Log.e("MainViewModel", "Error during groups search", e)
            _isLoadingGroups.value = false
        }
    }

    /**
     * Process groups data on background thread with 500m location filtering
     */
    private suspend fun processGroupsData(snapshot: DataSnapshot, destinationFilter: String?, cacheKey: String) {
        Log.d("GROUP_REFRESH", "MainViewModel.processGroupsData(): Processing ${snapshot.childrenCount} group snapshots")
        Log.i("Firebase", "MainViewModel.processGroupsData(): Processing ${snapshot.childrenCount} group snapshots")
        
        val newGroupsList = mutableListOf<Group>()
        val userLocation = _currentLocation.value

        // Log raw data for debugging
        Log.d("GROUP_REFRESH", "Raw data keys: ${snapshot.children.map { it.key }.take(5)}")
        Log.i("Firebase", "Raw data keys: ${snapshot.children.map { it.key }.take(5)}")

        for (groupSnapshot in snapshot.children) {
            Log.d("GROUP_REFRESH", "Processing group with key: ${groupSnapshot.key}")
            Log.i("Firebase", "Processing group with key: ${groupSnapshot.key}")
            
            try {
                val group = GroupReader.fromSnapshot(groupSnapshot)
                
                if (group != null) {
                    Log.d("GROUP_REFRESH", "Successfully parsed group: ${group.groupId}, destination: ${group.destinationName}")
                    Log.i("Firebase", "Successfully parsed group: ${group.groupId}, destination: ${group.destinationName}")
                    
                    // Skip cache, always use fresh data
                    if (passesFilters(group, destinationFilter, userLocation)) {
                        newGroupsList.add(group)
                        groupsCache[group.groupId!!] = group
                        Log.d("GROUP_REFRESH", "Added group to results: ${group.groupId}")
                        Log.i("Firebase", "Added group to results: ${group.groupId}")
                    } else {
                        Log.d("GROUP_REFRESH", "Group did not pass filters: ${group.groupId}")
                        Log.i("Firebase", "Group did not pass filters: ${group.groupId}")
                    }
                } else {
                    Log.e("GROUP_REFRESH", "Failed to parse group from snapshot with key: ${groupSnapshot.key}")
                    Log.e("Firebase", "Failed to parse group from snapshot with key: ${groupSnapshot.key}")
                }
            } catch (e: Exception) {
                Log.e("GROUP_REFRESH", "Error processing group: ${e.message}", e)
                Log.e("Firebase", "Error processing group: ${e.message}", e)
            }
        }

        // Sort and update UI on main thread
        val sortedList = newGroupsList.sortedByDescending { it.timestamp }
        Log.d("GROUP_REFRESH", "Final sorted list contains ${sortedList.size} groups")
        Log.i("Firebase", "Final sorted list contains ${sortedList.size} groups")
        
        // Update cache timestamp for this search
        lastSearchTimestamp[cacheKey] = System.currentTimeMillis()
        
        withContext(Dispatchers.Main) {
            _groups.value = sortedList
            _isLoadingGroups.value = false
            Log.d("GROUP_REFRESH", "Updated main thread groups list with ${sortedList.size} groups")
            Log.i("Firebase", "Updated main thread groups list with ${sortedList.size} groups")
        }
    }

    /**
     * Check if group passes filters - Location (500m) + expiry (30 minutes) + destination search
     */
    private fun passesFilters(group: Group, destinationFilter: String?, userLocation: Location?): Boolean {
        // Location filter - 500 meter radius
        if (userLocation != null && group.pickupLat != null && group.pickupLng != null) {
            val distance = calculateDistance(
                userLocation.latitude, userLocation.longitude,
                group.pickupLat!!, group.pickupLng!!
            )
            if (distance > searchRadiusMeters) {
                Log.d("MainViewModel", "Group '${group.originalDestination}' filtered out - ${distance.toInt()}m away")
                return false
            }
        } else if (userLocation == null) {
            // No user location available - don't show any groups
            return false
        }

        // Destination filter
        destinationFilter?.let { filter ->
            val searchableDestination = group.originalDestination ?: group.destinationName
            if (searchableDestination?.contains(filter, ignoreCase = true) != true) {
                return false
            }
        }

        // Only check if group is not expired (30 minutes)
        val thirtyMinutesAgo = System.currentTimeMillis() - (30 * 60 * 1000L)
        if (group.timestamp != null && group.timestamp!! <= thirtyMinutesAgo) {
            Log.d("MainViewModel", "Group '${group.originalDestination}' filtered out - expired")
            return false
        }

        Log.d("MainViewModel", "Group '${group.originalDestination}' included - active and nearby")
        return true
    }

    /**
     * Calculate straight-line distance between two points (Euclidean distance)
     * Fast and sufficient for short distances like 500m
     */
    private fun calculateDistance(lat1: Double, lng1: Double, lat2: Double, lng2: Double): Double {
        val earthRadius = 6371000.0 // Earth radius in meters
        val dLat = Math.toRadians(lat2 - lat1)
        val dLng = Math.toRadians(lng2 - lng1)
        
        // Convert to meters using simple approximation for short distances
        val deltaX = dLng * earthRadius * Math.cos(Math.toRadians((lat1 + lat2) / 2))
        val deltaY = dLat * earthRadius
        
        return Math.sqrt(deltaX * deltaX + deltaY * deltaY)
    }

    /**
     * Force refresh groups (for pull-to-refresh scenarios)
     */
    fun refreshGroups() {
        Log.d("GROUP_REFRESH", "MainViewModel.refreshGroups(): Clearing cache and performing search")
        Log.i("Firebase", "MainViewModel.refreshGroups(): Clearing cache and performing search")
        
        // Clear all caches to force fresh data
        groupsCache.clear()
        lastSearchTimestamp.clear()
        
        viewModelScope.launch {
            Log.d("GROUP_REFRESH", "MainViewModel.refreshGroups(): Launching search in viewModelScope")
            Log.i("Firebase", "MainViewModel.refreshGroups(): Launching search in viewModelScope")
            performGroupsSearch(_searchQuery.value.trim().takeIf { it.isNotBlank() })
        }
    }

    /**
     * Select a group for chat
     */
    fun selectGroup(group: Group?) {
        _selectedGroup.value = group
    }

    /**
     * Initialize Firebase references and user ID for the ViewModel
     */
    fun initializeFirebase(activeGroupsRef: DatabaseReference, firebaseUserId: String) {
        this.activeGroupsRef = activeGroupsRef
        this.currentFirebaseUserId = firebaseUserId
        Log.d("MainViewModel", "Firebase initialized with user ID: $firebaseUserId")
    }

    /**
     * Setup periodic memory cleanup to prevent memory leaks
     */
    private fun setupMemoryCleanup() {
        viewModelScope.launch(backgroundDispatcher) {
            while (true) {
                kotlinx.coroutines.delay(10 * 60 * 1000L) // Every 10 minutes
                cleanupMemory()
            }
        }
    }
    
    /**
     * Clean up memory periodically to prevent memory leaks
     */
    private suspend fun cleanupMemory() {
        // Remove oldest items from caches to limit memory usage
        withContext(computationDispatcher) {
            try {
                if (groupsCache.size > MAX_GROUPS_CACHE_SIZE) {
                    val entriesToRemove = groupsCache.size - MAX_GROUPS_CACHE_SIZE
                    val oldestEntries = groupsCache.entries
                        .sortedBy { it.value.timestamp ?: 0L }
                        .take(entriesToRemove)
                        .map { it.key }
                    
                    oldestEntries.forEach { groupsCache.remove(it) }
                }
                
                if (recentSearchesCache.size > MAX_RECENT_SEARCHES_SIZE) {
                    recentSearchesCache.subList(MAX_RECENT_SEARCHES_SIZE, recentSearchesCache.size).clear()
                }
                
                // Clean up search timestamp cache for old entries
                val currentTime = System.currentTimeMillis()
                lastSearchTimestamp.entries.removeIf { entry ->
                    currentTime - entry.value > CACHE_EXPIRY_MS
                }
                
                Log.d("MainViewModel", "Memory cleanup completed. Cache sizes: groups=${groupsCache.size}, searches=${recentSearchesCache.size}")
            } catch (e: Exception) {
                Log.e("MainViewModel", "Error during memory cleanup", e)
            }
        }
    }
    
    /**
     * Helper function to retry operations with exponential backoff
     */
    private suspend fun <T> withRetry(
        maxRetries: Int = this.maxRetries,
        operationName: String,
        operation: suspend () -> Result<T>
    ): Result<T> = withContext(Dispatchers.IO) {
        repeat(maxRetries) { attempt ->
            try {
                Log.d("MainViewModel", "Attempting $operationName ${attempt + 1}/$maxRetries")
                val result = operation()
                if (result.isSuccess) {
                    return@withContext result
                }
            } catch (e: Exception) {
                Log.w("MainViewModel", "$operationName failed on attempt ${attempt + 1}: ${e.message}")
                
                if (attempt == maxRetries - 1) {
                    // Last attempt failed
                    _errorState.value = "Failed to $operationName after $maxRetries attempts"
                    return@withContext Result.failure(e)
                }
                
                // Exponential backoff: wait longer between retries
                val delayMs = baseRetryDelayMs * (1 shl attempt) // 1s, 2s, 4s
                kotlinx.coroutines.delay(delayMs)
            }
        }
        Result.failure(Exception("Unexpected retry loop exit"))
    }
    
    /**
     * Clear error state
     */
    fun clearError() {
        _errorState.value = null
    }

    override fun onCleared() {
        super.onCleared()
        groupsCache.clear()
    }
}
